function super_constructor(_this, clazz, ...args) {    if (!clazz.prototype) return _this;    if (!_this) {        _this = Object.create(clazz.prototype);    }    let super_class = Object.getPrototypeOf(clazz.prototype);    if (!super_class || !super_class.constructor) return _this;    var res;    res = super_class.constructor.call(_this, ...args);    if (res && res !== _this) {        Object.setPrototypeOf(res, clazz.prototype);        return res;    }    return _this;}async function file_exists(filename) {    try {        await Deno.stat(filename);        return true;    } catch (error) {        if (error instanceof Deno.errors.NotFound) {            return false;        } else {            throw error;        }    }}function random_int(min, max) {    return Math.floor(Math.random() * (max - min + 1)) + min;}function format_currency(val) {    return '$' + val.toFixed(2).replace(/\d(?=(\d{3})+\.)/g, '$&,').slice(0, -3);}function deferred() {    let methods;    const promise = new Promise((resolve, reject)=>{        methods = {            resolve,            reject        };    });    return Object.assign(promise, methods);}class MuxAsyncIterator {    iteratorCount = 0;    yields = [];    throws = [];    signal = deferred();    add(iterator) {        ++this.iteratorCount;        this.callIteratorNext(iterator);    }    async callIteratorNext(iterator) {        try {            const { value , done  } = await iterator.next();            if (done) {                --this.iteratorCount;            } else {                this.yields.push({                    iterator,                    value                });            }        } catch (e) {            this.throws.push(e);        }        this.signal.resolve();    }    async *iterate() {        while(this.iteratorCount > 0){            await this.signal;            for(let i = 0; i < this.yields.length; i++){                const { iterator , value  } = this.yields[i];                yield value;                this.callIteratorNext(iterator);            }            if (this.throws.length) {                for (const e of this.throws){                    throw e;                }                this.throws.length = 0;            }            this.yields.length = 0;            this.signal = deferred();        }    }    [Symbol.asyncIterator]() {        return this.iterate();    }}globalThis.Deno?.noColor ?? true;new RegExp([    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"), "g");var DiffType;(function(DiffType) {    DiffType["removed"] = "removed";    DiffType["common"] = "common";    DiffType["added"] = "added";})(DiffType || (DiffType = {}));class DenoStdInternalError extends Error {    constructor(message){        super(message);        this.name = "DenoStdInternalError";    }}function assert(expr, msg = "") {    if (!expr) {        throw new DenoStdInternalError(msg);    }}async function writeAll(w, arr) {    let nwritten = 0;    while(nwritten < arr.length){        nwritten += await w.write(arr.subarray(nwritten));    }}TextDecoder;TextEncoder;function validateIntegerRange(value, name, min = -2147483648, max = 2147483647) {    if (!Number.isInteger(value)) {        throw new Error(`${name} must be 'an integer' but was ${value}`);    }    if (value < min || value > max) {        throw new Error(`${name} must be >= ${min} && <= ${max}. Value was ${value}`);    }}function createIterResult(value, done) {    return {        value,        done    };}let defaultMaxListeners = 10;class EventEmitter {    static captureRejectionSymbol = Symbol.for("nodejs.rejection");    static errorMonitor = Symbol("events.errorMonitor");    static get defaultMaxListeners() {        return defaultMaxListeners;    }    static set defaultMaxListeners(value) {        defaultMaxListeners = value;    }    maxListeners;    _events;    constructor(){        this._events = new Map();    }    _addListener(eventName, listener, prepend) {        this.emit("newListener", eventName, listener);        if (this._events.has(eventName)) {            const listeners = this._events.get(eventName);            if (prepend) {                listeners.unshift(listener);            } else {                listeners.push(listener);            }        } else {            this._events.set(eventName, [                listener            ]);        }        const max = this.getMaxListeners();        if (max > 0 && this.listenerCount(eventName) > max) {            const warning = new Error(`Possible EventEmitter memory leak detected.         ${this.listenerCount(eventName)} ${eventName.toString()} listeners.         Use emitter.setMaxListeners() to increase limit`);            warning.name = "MaxListenersExceededWarning";            console.warn(warning);        }        return this;    }    addListener(eventName, listener) {        return this._addListener(eventName, listener, false);    }    emit(eventName, ...args) {        if (this._events.has(eventName)) {            if (eventName === "error" && this._events.get(EventEmitter.errorMonitor)) {                this.emit(EventEmitter.errorMonitor, ...args);            }            const listeners = this._events.get(eventName).slice();            for (const listener of listeners){                try {                    listener.apply(this, args);                } catch (err) {                    this.emit("error", err);                }            }            return true;        } else if (eventName === "error") {            if (this._events.get(EventEmitter.errorMonitor)) {                this.emit(EventEmitter.errorMonitor, ...args);            }            const errMsg = args.length > 0 ? args[0] : Error("Unhandled error.");            throw errMsg;        }        return false;    }    eventNames() {        return Array.from(this._events.keys());    }    getMaxListeners() {        return this.maxListeners || EventEmitter.defaultMaxListeners;    }    listenerCount(eventName) {        if (this._events.has(eventName)) {            return this._events.get(eventName).length;        } else {            return 0;        }    }    static listenerCount(emitter, eventName) {        return emitter.listenerCount(eventName);    }    _listeners(target, eventName, unwrap) {        if (!target._events.has(eventName)) {            return [];        }        const eventListeners = target._events.get(eventName);        return unwrap ? this.unwrapListeners(eventListeners) : eventListeners.slice(0);    }    unwrapListeners(arr) {        const unwrappedListeners = new Array(arr.length);        for(let i = 0; i < arr.length; i++){            unwrappedListeners[i] = arr[i]["listener"] || arr[i];        }        return unwrappedListeners;    }    listeners(eventName) {        return this._listeners(this, eventName, true);    }    rawListeners(eventName) {        return this._listeners(this, eventName, false);    }    off(eventName, listener) {        return this.removeListener(eventName, listener);    }    on(eventName, listener) {        return this._addListener(eventName, listener, false);    }    once(eventName, listener) {        const wrapped = this.onceWrap(eventName, listener);        this.on(eventName, wrapped);        return this;    }    onceWrap(eventName, listener) {        const wrapper = function(...args) {            this.context.removeListener(this.eventName, this.rawListener);            this.listener.apply(this.context, args);        };        const wrapperContext = {            eventName: eventName,            listener: listener,            rawListener: wrapper,            context: this        };        const wrapped = wrapper.bind(wrapperContext);        wrapperContext.rawListener = wrapped;        wrapped.listener = listener;        return wrapped;    }    prependListener(eventName, listener) {        return this._addListener(eventName, listener, true);    }    prependOnceListener(eventName, listener) {        const wrapped = this.onceWrap(eventName, listener);        this.prependListener(eventName, wrapped);        return this;    }    removeAllListeners(eventName) {        if (this._events === undefined) {            return this;        }        if (eventName) {            if (this._events.has(eventName)) {                const listeners = this._events.get(eventName).slice();                this._events.delete(eventName);                for (const listener of listeners){                    this.emit("removeListener", eventName, listener);                }            }        } else {            const eventList = this.eventNames();            eventList.map((value)=>{                this.removeAllListeners(value);            });        }        return this;    }    removeListener(eventName, listener) {        if (this._events.has(eventName)) {            const arr = this._events.get(eventName);            assert(arr);            let listenerIndex = -1;            for(let i = arr.length - 1; i >= 0; i--){                if (arr[i] == listener || arr[i] && arr[i]["listener"] == listener) {                    listenerIndex = i;                    break;                }            }            if (listenerIndex >= 0) {                arr.splice(listenerIndex, 1);                this.emit("removeListener", eventName, listener);                if (arr.length === 0) {                    this._events.delete(eventName);                }            }        }        return this;    }    setMaxListeners(n) {        if (n !== Infinity) {            if (n === 0) {                n = Infinity;            } else {                validateIntegerRange(n, "maxListeners", 0);            }        }        this.maxListeners = n;        return this;    }    static once(emitter, name) {        return new Promise((resolve, reject)=>{            if (emitter instanceof EventTarget) {                emitter.addEventListener(name, (...args)=>{                    resolve(args);                }, {                    once: true,                    passive: false,                    capture: false                });                return;            } else if (emitter instanceof EventEmitter) {                const eventListener = (...args)=>{                    if (errorListener !== undefined) {                        emitter.removeListener("error", errorListener);                    }                    resolve(args);                };                let errorListener;                if (name !== "error") {                    errorListener = (err)=>{                        emitter.removeListener(name, eventListener);                        reject(err);                    };                    emitter.once("error", errorListener);                }                emitter.once(name, eventListener);                return;            }        });    }    static on(emitter, event) {        const unconsumedEventValues = [];        const unconsumedPromises = [];        let error = null;        let finished = false;        const iterator = {            next () {                const value = unconsumedEventValues.shift();                if (value) {                    return Promise.resolve(createIterResult(value, false));                }                if (error) {                    const p = Promise.reject(error);                    error = null;                    return p;                }                if (finished) {                    return Promise.resolve(createIterResult(undefined, true));                }                return new Promise(function(resolve, reject) {                    unconsumedPromises.push({                        resolve,                        reject                    });                });            },            return () {                emitter.removeListener(event, eventHandler);                emitter.removeListener("error", errorHandler);                finished = true;                for (const promise of unconsumedPromises){                    promise.resolve(createIterResult(undefined, true));                }                return Promise.resolve(createIterResult(undefined, true));            },            throw (err) {                error = err;                emitter.removeListener(event, eventHandler);                emitter.removeListener("error", errorHandler);            },            [Symbol.asyncIterator] () {                return this;            }        };        emitter.on(event, eventHandler);        emitter.on("error", errorHandler);        return iterator;        function eventHandler(...args) {            const promise = unconsumedPromises.shift();            if (promise) {                promise.resolve(createIterResult(args, false));            } else {                unconsumedEventValues.push(args);            }        }        function errorHandler(err) {            finished = true;            const toError = unconsumedPromises.shift();            if (toError) {                toError.reject(err);            } else {                error = err;            }            iterator.return();        }    }}EventEmitter.captureRejectionSymbol;EventEmitter.errorMonitor;EventEmitter.listenerCount;EventEmitter.on;EventEmitter.once;Object.assign(EventEmitter, {    EventEmitter});function concat(...buf) {    let length = 0;    for (const b of buf){        length += b.length;    }    const output = new Uint8Array(length);    let index = 0;    for (const b of buf){        output.set(b, index);        index += b.length;    }    return output;}function copy(src, dst, off = 0) {    off = Math.max(0, Math.min(off, dst.byteLength));    const dstBytesAvailable = dst.byteLength - off;    if (src.byteLength > dstBytesAvailable) {        src = src.subarray(0, dstBytesAvailable);    }    dst.set(src, off);    return src.byteLength;}const DEFAULT_BUF_SIZE = 4096;const MIN_BUF_SIZE = 16;const CR = "\r".charCodeAt(0);const LF = "\n".charCodeAt(0);class BufferFullError extends Error {    partial;    name;    constructor(partial){        super("Buffer full");        this.partial = partial;        this.name = "BufferFullError";    }}class PartialReadError extends Error {    name = "PartialReadError";    partial;    constructor(){        super("Encountered UnexpectedEof, data only partially read");    }}class BufReader {    buf;    rd;    r = 0;    w = 0;    eof = false;    static create(r, size = 4096) {        return r instanceof BufReader ? r : new BufReader(r, size);    }    constructor(rd, size = 4096){        if (size < 16) {            size = MIN_BUF_SIZE;        }        this._reset(new Uint8Array(size), rd);    }    size() {        return this.buf.byteLength;    }    buffered() {        return this.w - this.r;    }    async _fill() {        if (this.r > 0) {            this.buf.copyWithin(0, this.r, this.w);            this.w -= this.r;            this.r = 0;        }        if (this.w >= this.buf.byteLength) {            throw Error("bufio: tried to fill full buffer");        }        for(let i = 100; i > 0; i--){            const rr = await this.rd.read(this.buf.subarray(this.w));            if (rr === null) {                this.eof = true;                return;            }            assert(rr >= 0, "negative read");            this.w += rr;            if (rr > 0) {                return;            }        }        throw new Error(`No progress after ${100} read() calls`);    }    reset(r) {        this._reset(this.buf, r);    }    _reset(buf, rd) {        this.buf = buf;        this.rd = rd;        this.eof = false;    }    async read(p) {        let rr = p.byteLength;        if (p.byteLength === 0) return rr;        if (this.r === this.w) {            if (p.byteLength >= this.buf.byteLength) {                const rr = await this.rd.read(p);                const nread = rr ?? 0;                assert(nread >= 0, "negative read");                return rr;            }            this.r = 0;            this.w = 0;            rr = await this.rd.read(this.buf);            if (rr === 0 || rr === null) return rr;            assert(rr >= 0, "negative read");            this.w += rr;        }        const copied = copy(this.buf.subarray(this.r, this.w), p, 0);        this.r += copied;        return copied;    }    async readFull(p) {        let bytesRead = 0;        while(bytesRead < p.length){            try {                const rr = await this.read(p.subarray(bytesRead));                if (rr === null) {                    if (bytesRead === 0) {                        return null;                    } else {                        throw new PartialReadError();                    }                }                bytesRead += rr;            } catch (err) {                err.partial = p.subarray(0, bytesRead);                throw err;            }        }        return p;    }    async readByte() {        while(this.r === this.w){            if (this.eof) return null;            await this._fill();        }        const c = this.buf[this.r];        this.r++;        return c;    }    async readString(delim) {        if (delim.length !== 1) {            throw new Error("Delimiter should be a single character");        }        const buffer = await this.readSlice(delim.charCodeAt(0));        if (buffer === null) return null;        return new TextDecoder().decode(buffer);    }    async readLine() {        let line;        try {            line = await this.readSlice(LF);        } catch (err) {            let { partial  } = err;            assert(partial instanceof Uint8Array, "bufio: caught error from `readSlice()` without `partial` property");            if (!(err instanceof BufferFullError)) {                throw err;            }            if (!this.eof && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {                assert(this.r > 0, "bufio: tried to rewind past start of buffer");                this.r--;                partial = partial.subarray(0, partial.byteLength - 1);            }            return {                line: partial,                more: !this.eof            };        }        if (line === null) {            return null;        }        if (line.byteLength === 0) {            return {                line,                more: false            };        }        if (line[line.byteLength - 1] == LF) {            let drop = 1;            if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {                drop = 2;            }            line = line.subarray(0, line.byteLength - drop);        }        return {            line,            more: false        };    }    async readSlice(delim) {        let s = 0;        let slice;        while(true){            let i = this.buf.subarray(this.r + s, this.w).indexOf(delim);            if (i >= 0) {                i += s;                slice = this.buf.subarray(this.r, this.r + i + 1);                this.r += i + 1;                break;            }            if (this.eof) {                if (this.r === this.w) {                    return null;                }                slice = this.buf.subarray(this.r, this.w);                this.r = this.w;                break;            }            if (this.buffered() >= this.buf.byteLength) {                this.r = this.w;                const oldbuf = this.buf;                const newbuf = this.buf.slice(0);                this.buf = newbuf;                throw new BufferFullError(oldbuf);            }            s = this.w - this.r;            try {                await this._fill();            } catch (err) {                err.partial = slice;                throw err;            }        }        return slice;    }    async peek(n) {        if (n < 0) {            throw Error("negative count");        }        let avail = this.w - this.r;        while(avail < n && avail < this.buf.byteLength && !this.eof){            try {                await this._fill();            } catch (err) {                err.partial = this.buf.subarray(this.r, this.w);                throw err;            }            avail = this.w - this.r;        }        if (avail === 0 && this.eof) {            return null;        } else if (avail < n && this.eof) {            return this.buf.subarray(this.r, this.r + avail);        } else if (avail < n) {            throw new BufferFullError(this.buf.subarray(this.r, this.w));        }        return this.buf.subarray(this.r, this.r + n);    }}class AbstractBufBase {    buf;    usedBufferBytes = 0;    err = null;    size() {        return this.buf.byteLength;    }    available() {        return this.buf.byteLength - this.usedBufferBytes;    }    buffered() {        return this.usedBufferBytes;    }}class BufWriter extends AbstractBufBase {    writer;    static create(writer, size = 4096) {        return writer instanceof BufWriter ? writer : new BufWriter(writer, size);    }    constructor(writer, size = 4096){        super();        this.writer = writer;        if (size <= 0) {            size = DEFAULT_BUF_SIZE;        }        this.buf = new Uint8Array(size);    }    reset(w) {        this.err = null;        this.usedBufferBytes = 0;        this.writer = w;    }    async flush() {        if (this.err !== null) throw this.err;        if (this.usedBufferBytes === 0) return;        try {            await writeAll(this.writer, this.buf.subarray(0, this.usedBufferBytes));        } catch (e) {            this.err = e;            throw e;        }        this.buf = new Uint8Array(this.buf.length);        this.usedBufferBytes = 0;    }    async write(data) {        if (this.err !== null) throw this.err;        if (data.length === 0) return 0;        let totalBytesWritten = 0;        let numBytesWritten = 0;        while(data.byteLength > this.available()){            if (this.buffered() === 0) {                try {                    numBytesWritten = await this.writer.write(data);                } catch (e) {                    this.err = e;                    throw e;                }            } else {                numBytesWritten = copy(data, this.buf, this.usedBufferBytes);                this.usedBufferBytes += numBytesWritten;                await this.flush();            }            totalBytesWritten += numBytesWritten;            data = data.subarray(numBytesWritten);        }        numBytesWritten = copy(data, this.buf, this.usedBufferBytes);        this.usedBufferBytes += numBytesWritten;        totalBytesWritten += numBytesWritten;        return totalBytesWritten;    }}const decoder = new TextDecoder();const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/g;function str(buf) {    if (buf == null) {        return "";    } else {        return decoder.decode(buf);    }}function charCode(s) {    return s.charCodeAt(0);}class TextProtoReader {    r;    constructor(r){        this.r = r;    }    async readLine() {        const s = await this.readLineSlice();        if (s === null) return null;        return str(s);    }    async readMIMEHeader() {        const m = new Headers();        let line;        let buf = await this.r.peek(1);        if (buf === null) {            return null;        } else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {            line = await this.readLineSlice();        }        buf = await this.r.peek(1);        if (buf === null) {            throw new Deno.errors.UnexpectedEof();        } else if (buf[0] == charCode(" ") || buf[0] == charCode("\t")) {            throw new Deno.errors.InvalidData(`malformed MIME header initial line: ${str(line)}`);        }        while(true){            const kv = await this.readLineSlice();            if (kv === null) throw new Deno.errors.UnexpectedEof();            if (kv.byteLength === 0) return m;            let i = kv.indexOf(charCode(":"));            if (i < 0) {                throw new Deno.errors.InvalidData(`malformed MIME header line: ${str(kv)}`);            }            const key = str(kv.subarray(0, i));            if (key == "") {                continue;            }            i++;            while(i < kv.byteLength && (kv[i] == charCode(" ") || kv[i] == charCode("\t"))){                i++;            }            const value = str(kv.subarray(i)).replace(invalidHeaderCharRegex, encodeURI);            try {                m.append(key, value);            } catch  {}        }    }    async readLineSlice() {        let line;        while(true){            const r = await this.r.readLine();            if (r === null) return null;            const { line: l , more  } = r;            if (!line && !more) {                if (this.skipSpace(l) === 0) {                    return new Uint8Array(0);                }                return l;            }            line = line ? concat(line, l) : l;            if (!more) {                break;            }        }        return line;    }    skipSpace(l) {        let n = 0;        for(let i = 0; i < l.length; i++){            if (l[i] === charCode(" ") || l[i] === charCode("\t")) {                continue;            }            n++;        }        return n;    }}var Status;(function(Status) {    Status[Status["Continue"] = 100] = "Continue";    Status[Status["SwitchingProtocols"] = 101] = "SwitchingProtocols";    Status[Status["Processing"] = 102] = "Processing";    Status[Status["EarlyHints"] = 103] = "EarlyHints";    Status[Status["OK"] = 200] = "OK";    Status[Status["Created"] = 201] = "Created";    Status[Status["Accepted"] = 202] = "Accepted";    Status[Status["NonAuthoritativeInfo"] = 203] = "NonAuthoritativeInfo";    Status[Status["NoContent"] = 204] = "NoContent";    Status[Status["ResetContent"] = 205] = "ResetContent";    Status[Status["PartialContent"] = 206] = "PartialContent";    Status[Status["MultiStatus"] = 207] = "MultiStatus";    Status[Status["AlreadyReported"] = 208] = "AlreadyReported";    Status[Status["IMUsed"] = 226] = "IMUsed";    Status[Status["MultipleChoices"] = 300] = "MultipleChoices";    Status[Status["MovedPermanently"] = 301] = "MovedPermanently";    Status[Status["Found"] = 302] = "Found";    Status[Status["SeeOther"] = 303] = "SeeOther";    Status[Status["NotModified"] = 304] = "NotModified";    Status[Status["UseProxy"] = 305] = "UseProxy";    Status[Status["TemporaryRedirect"] = 307] = "TemporaryRedirect";    Status[Status["PermanentRedirect"] = 308] = "PermanentRedirect";    Status[Status["BadRequest"] = 400] = "BadRequest";    Status[Status["Unauthorized"] = 401] = "Unauthorized";    Status[Status["PaymentRequired"] = 402] = "PaymentRequired";    Status[Status["Forbidden"] = 403] = "Forbidden";    Status[Status["NotFound"] = 404] = "NotFound";    Status[Status["MethodNotAllowed"] = 405] = "MethodNotAllowed";    Status[Status["NotAcceptable"] = 406] = "NotAcceptable";    Status[Status["ProxyAuthRequired"] = 407] = "ProxyAuthRequired";    Status[Status["RequestTimeout"] = 408] = "RequestTimeout";    Status[Status["Conflict"] = 409] = "Conflict";    Status[Status["Gone"] = 410] = "Gone";    Status[Status["LengthRequired"] = 411] = "LengthRequired";    Status[Status["PreconditionFailed"] = 412] = "PreconditionFailed";    Status[Status["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";    Status[Status["RequestURITooLong"] = 414] = "RequestURITooLong";    Status[Status["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";    Status[Status["RequestedRangeNotSatisfiable"] = 416] = "RequestedRangeNotSatisfiable";    Status[Status["ExpectationFailed"] = 417] = "ExpectationFailed";    Status[Status["Teapot"] = 418] = "Teapot";    Status[Status["MisdirectedRequest"] = 421] = "MisdirectedRequest";    Status[Status["UnprocessableEntity"] = 422] = "UnprocessableEntity";    Status[Status["Locked"] = 423] = "Locked";    Status[Status["FailedDependency"] = 424] = "FailedDependency";    Status[Status["TooEarly"] = 425] = "TooEarly";    Status[Status["UpgradeRequired"] = 426] = "UpgradeRequired";    Status[Status["PreconditionRequired"] = 428] = "PreconditionRequired";    Status[Status["TooManyRequests"] = 429] = "TooManyRequests";    Status[Status["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";    Status[Status["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";    Status[Status["InternalServerError"] = 500] = "InternalServerError";    Status[Status["NotImplemented"] = 501] = "NotImplemented";    Status[Status["BadGateway"] = 502] = "BadGateway";    Status[Status["ServiceUnavailable"] = 503] = "ServiceUnavailable";    Status[Status["GatewayTimeout"] = 504] = "GatewayTimeout";    Status[Status["HTTPVersionNotSupported"] = 505] = "HTTPVersionNotSupported";    Status[Status["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";    Status[Status["InsufficientStorage"] = 507] = "InsufficientStorage";    Status[Status["LoopDetected"] = 508] = "LoopDetected";    Status[Status["NotExtended"] = 510] = "NotExtended";    Status[Status["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";})(Status || (Status = {}));const STATUS_TEXT = new Map([    [        Status.Continue,        "Continue"    ],    [        Status.SwitchingProtocols,        "Switching Protocols"    ],    [        Status.Processing,        "Processing"    ],    [        Status.EarlyHints,        "Early Hints"    ],    [        Status.OK,        "OK"    ],    [        Status.Created,        "Created"    ],    [        Status.Accepted,        "Accepted"    ],    [        Status.NonAuthoritativeInfo,        "Non-Authoritative Information"    ],    [        Status.NoContent,        "No Content"    ],    [        Status.ResetContent,        "Reset Content"    ],    [        Status.PartialContent,        "Partial Content"    ],    [        Status.MultiStatus,        "Multi-Status"    ],    [        Status.AlreadyReported,        "Already Reported"    ],    [        Status.IMUsed,        "IM Used"    ],    [        Status.MultipleChoices,        "Multiple Choices"    ],    [        Status.MovedPermanently,        "Moved Permanently"    ],    [        Status.Found,        "Found"    ],    [        Status.SeeOther,        "See Other"    ],    [        Status.NotModified,        "Not Modified"    ],    [        Status.UseProxy,        "Use Proxy"    ],    [        Status.TemporaryRedirect,        "Temporary Redirect"    ],    [        Status.PermanentRedirect,        "Permanent Redirect"    ],    [        Status.BadRequest,        "Bad Request"    ],    [        Status.Unauthorized,        "Unauthorized"    ],    [        Status.PaymentRequired,        "Payment Required"    ],    [        Status.Forbidden,        "Forbidden"    ],    [        Status.NotFound,        "Not Found"    ],    [        Status.MethodNotAllowed,        "Method Not Allowed"    ],    [        Status.NotAcceptable,        "Not Acceptable"    ],    [        Status.ProxyAuthRequired,        "Proxy Authentication Required"    ],    [        Status.RequestTimeout,        "Request Timeout"    ],    [        Status.Conflict,        "Conflict"    ],    [        Status.Gone,        "Gone"    ],    [        Status.LengthRequired,        "Length Required"    ],    [        Status.PreconditionFailed,        "Precondition Failed"    ],    [        Status.RequestEntityTooLarge,        "Request Entity Too Large"    ],    [        Status.RequestURITooLong,        "Request URI Too Long"    ],    [        Status.UnsupportedMediaType,        "Unsupported Media Type"    ],    [        Status.RequestedRangeNotSatisfiable,        "Requested Range Not Satisfiable"    ],    [        Status.ExpectationFailed,        "Expectation Failed"    ],    [        Status.Teapot,        "I'm a teapot"    ],    [        Status.MisdirectedRequest,        "Misdirected Request"    ],    [        Status.UnprocessableEntity,        "Unprocessable Entity"    ],    [        Status.Locked,        "Locked"    ],    [        Status.FailedDependency,        "Failed Dependency"    ],    [        Status.TooEarly,        "Too Early"    ],    [        Status.UpgradeRequired,        "Upgrade Required"    ],    [        Status.PreconditionRequired,        "Precondition Required"    ],    [        Status.TooManyRequests,        "Too Many Requests"    ],    [        Status.RequestHeaderFieldsTooLarge,        "Request Header Fields Too Large"    ],    [        Status.UnavailableForLegalReasons,        "Unavailable For Legal Reasons"    ],    [        Status.InternalServerError,        "Internal Server Error"    ],    [        Status.NotImplemented,        "Not Implemented"    ],    [        Status.BadGateway,        "Bad Gateway"    ],    [        Status.ServiceUnavailable,        "Service Unavailable"    ],    [        Status.GatewayTimeout,        "Gateway Timeout"    ],    [        Status.HTTPVersionNotSupported,        "HTTP Version Not Supported"    ],    [        Status.VariantAlsoNegotiates,        "Variant Also Negotiates"    ],    [        Status.InsufficientStorage,        "Insufficient Storage"    ],    [        Status.LoopDetected,        "Loop Detected"    ],    [        Status.NotExtended,        "Not Extended"    ],    [        Status.NetworkAuthenticationRequired,        "Network Authentication Required"    ]]);const encoder = new TextEncoder();function emptyReader() {    return {        read (_) {            return Promise.resolve(null);        }    };}function bodyReader(contentLength, r) {    let totalRead = 0;    let finished = false;    async function read(buf) {        if (finished) return null;        let result;        const remaining = contentLength - totalRead;        if (remaining >= buf.byteLength) {            result = await r.read(buf);        } else {            const readBuf = buf.subarray(0, remaining);            result = await r.read(readBuf);        }        if (result !== null) {            totalRead += result;        }        finished = totalRead === contentLength;        return result;    }    return {        read    };}function chunkedBodyReader(h, r) {    const tp = new TextProtoReader(r);    let finished = false;    const chunks = [];    async function read(buf) {        if (finished) return null;        const [chunk] = chunks;        if (chunk) {            const chunkRemaining = chunk.data.byteLength - chunk.offset;            const readLength = Math.min(chunkRemaining, buf.byteLength);            for(let i = 0; i < readLength; i++){                buf[i] = chunk.data[chunk.offset + i];            }            chunk.offset += readLength;            if (chunk.offset === chunk.data.byteLength) {                chunks.shift();                if (await tp.readLine() === null) {                    throw new Deno.errors.UnexpectedEof();                }            }            return readLength;        }        const line = await tp.readLine();        if (line === null) throw new Deno.errors.UnexpectedEof();        const [chunkSizeString] = line.split(";");        const chunkSize = parseInt(chunkSizeString, 16);        if (Number.isNaN(chunkSize) || chunkSize < 0) {            throw new Deno.errors.InvalidData("Invalid chunk size");        }        if (chunkSize > 0) {            if (chunkSize > buf.byteLength) {                let eof = await r.readFull(buf);                if (eof === null) {                    throw new Deno.errors.UnexpectedEof();                }                const restChunk = new Uint8Array(chunkSize - buf.byteLength);                eof = await r.readFull(restChunk);                if (eof === null) {                    throw new Deno.errors.UnexpectedEof();                } else {                    chunks.push({                        offset: 0,                        data: restChunk                    });                }                return buf.byteLength;            } else {                const bufToFill = buf.subarray(0, chunkSize);                const eof = await r.readFull(bufToFill);                if (eof === null) {                    throw new Deno.errors.UnexpectedEof();                }                if (await tp.readLine() === null) {                    throw new Deno.errors.UnexpectedEof();                }                return chunkSize;            }        } else {            assert(chunkSize === 0);            if (await r.readLine() === null) {                throw new Deno.errors.UnexpectedEof();            }            await readTrailers(h, r);            finished = true;            return null;        }    }    return {        read    };}function isProhibidedForTrailer(key) {    const s = new Set([        "transfer-encoding",        "content-length",        "trailer"    ]);    return s.has(key.toLowerCase());}async function readTrailers(headers, r) {    const trailers = parseTrailer(headers.get("trailer"));    if (trailers == null) return;    const trailerNames = [        ...trailers.keys()    ];    const tp = new TextProtoReader(r);    const result = await tp.readMIMEHeader();    if (result == null) {        throw new Deno.errors.InvalidData("Missing trailer header.");    }    const undeclared = [        ...result.keys()    ].filter((k)=>!trailerNames.includes(k));    if (undeclared.length > 0) {        throw new Deno.errors.InvalidData(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);    }    for (const [k, v] of result){        headers.append(k, v);    }    const missingTrailers = trailerNames.filter((k)=>!result.has(k));    if (missingTrailers.length > 0) {        throw new Deno.errors.InvalidData(`Missing trailers: ${Deno.inspect(missingTrailers)}.`);    }    headers.delete("trailer");}function parseTrailer(field) {    if (field == null) {        return undefined;    }    const trailerNames = field.split(",").map((v)=>v.trim().toLowerCase());    if (trailerNames.length === 0) {        throw new Deno.errors.InvalidData("Empty trailer header.");    }    const prohibited = trailerNames.filter((k)=>isProhibidedForTrailer(k));    if (prohibited.length > 0) {        throw new Deno.errors.InvalidData(`Prohibited trailer names: ${Deno.inspect(prohibited)}.`);    }    return new Headers(trailerNames.map((key)=>[            key,            ""        ]));}async function writeChunkedBody(w, r) {    for await (const chunk of Deno.iter(r)){        if (chunk.byteLength <= 0) continue;        const start = encoder.encode(`${chunk.byteLength.toString(16)}\r\n`);        const end = encoder.encode("\r\n");        await w.write(start);        await w.write(chunk);        await w.write(end);        await w.flush();    }    const endChunk = encoder.encode("0\r\n\r\n");    await w.write(endChunk);}async function writeTrailers(w, headers, trailers) {    const trailer = headers.get("trailer");    if (trailer === null) {        throw new TypeError("Missing trailer header.");    }    const transferEncoding = headers.get("transfer-encoding");    if (transferEncoding === null || !transferEncoding.match(/^chunked/)) {        throw new TypeError(`Trailers are only allowed for "transfer-encoding: chunked", got "transfer-encoding: ${transferEncoding}".`);    }    const writer = BufWriter.create(w);    const trailerNames = trailer.split(",").map((s)=>s.trim().toLowerCase());    const prohibitedTrailers = trailerNames.filter((k)=>isProhibidedForTrailer(k));    if (prohibitedTrailers.length > 0) {        throw new TypeError(`Prohibited trailer names: ${Deno.inspect(prohibitedTrailers)}.`);    }    const undeclared = [        ...trailers.keys()    ].filter((k)=>!trailerNames.includes(k));    if (undeclared.length > 0) {        throw new TypeError(`Undeclared trailers: ${Deno.inspect(undeclared)}.`);    }    for (const [key, value] of trailers){        await writer.write(encoder.encode(`${key}: ${value}\r\n`));    }    await writer.write(encoder.encode("\r\n"));    await writer.flush();}async function writeResponse(w, r) {    const statusCode = r.status || 200;    const statusText = STATUS_TEXT.get(statusCode);    const writer = BufWriter.create(w);    if (!statusText) {        throw new Deno.errors.InvalidData("Bad status code");    }    if (!r.body) {        r.body = new Uint8Array();    }    if (typeof r.body === "string") {        r.body = encoder.encode(r.body);    }    let out = `HTTP/${1}.${1} ${statusCode} ${statusText}\r\n`;    const headers = r.headers ?? new Headers();    if (r.body && !headers.get("content-length")) {        if (r.body instanceof Uint8Array) {            out += `content-length: ${r.body.byteLength}\r\n`;        } else if (!headers.get("transfer-encoding")) {            out += "transfer-encoding: chunked\r\n";        }    }    for (const [key, value] of headers){        out += `${key}: ${value}\r\n`;    }    out += `\r\n`;    const header = encoder.encode(out);    const n = await writer.write(header);    assert(n === header.byteLength);    if (r.body instanceof Uint8Array) {        const n = await writer.write(r.body);        assert(n === r.body.byteLength);    } else if (headers.has("content-length")) {        const contentLength = headers.get("content-length");        assert(contentLength != null);        const bodyLength = parseInt(contentLength);        const n = await Deno.copy(r.body, writer);        assert(n === bodyLength);    } else {        await writeChunkedBody(writer, r.body);    }    if (r.trailers) {        const t = await r.trailers();        await writeTrailers(writer, headers, t);    }    await writer.flush();}class ServerRequest {    url;    method;    proto;    protoMinor;    protoMajor;    headers;    conn;    r;    w;    #done = deferred();    #contentLength = undefined;    #body = undefined;    #finalized = false;    get done() {        return this.#done.then((e)=>e);    }    get contentLength() {        if (this.#contentLength === undefined) {            const cl = this.headers.get("content-length");            if (cl) {                this.#contentLength = parseInt(cl);                if (Number.isNaN(this.#contentLength)) {                    this.#contentLength = null;                }            } else {                this.#contentLength = null;            }        }        return this.#contentLength;    }    get body() {        if (!this.#body) {            if (this.contentLength != null) {                this.#body = bodyReader(this.contentLength, this.r);            } else {                const transferEncoding = this.headers.get("transfer-encoding");                if (transferEncoding != null) {                    const parts = transferEncoding.split(",").map((e)=>e.trim().toLowerCase());                    assert(parts.includes("chunked"), 'transfer-encoding must include "chunked" if content-length is not set');                    this.#body = chunkedBodyReader(this.headers, this.r);                } else {                    this.#body = emptyReader();                }            }        }        return this.#body;    }    async respond(r) {        let err;        try {            await writeResponse(this.w, r);        } catch (e) {            try {                this.conn.close();            } catch  {}            err = e;        }        this.#done.resolve(err);        if (err) {            throw err;        }    }    async finalize() {        if (this.#finalized) return;        const body = this.body;        const buf = new Uint8Array(1024);        while(await body.read(buf) !== null){}        this.#finalized = true;    }}function parseHTTPVersion(vers) {    switch(vers){        case "HTTP/1.1":            return [                1,                1            ];        case "HTTP/1.0":            return [                1,                0            ];        default:            {                if (!vers.startsWith("HTTP/")) {                    break;                }                const dot = vers.indexOf(".");                if (dot < 0) {                    break;                }                const majorStr = vers.substring(vers.indexOf("/") + 1, dot);                const major = Number(majorStr);                if (!Number.isInteger(major) || major < 0 || major > 1000000) {                    break;                }                const minorStr = vers.substring(dot + 1);                const minor = Number(minorStr);                if (!Number.isInteger(minor) || minor < 0 || minor > 1000000) {                    break;                }                return [                    major,                    minor                ];            }    }    throw new Error(`malformed HTTP version ${vers}`);}async function readRequest(conn, bufr) {    const tp = new TextProtoReader(bufr);    const firstLine = await tp.readLine();    if (firstLine === null) return null;    const headers = await tp.readMIMEHeader();    if (headers === null) throw new Deno.errors.UnexpectedEof();    const req = new ServerRequest();    req.conn = conn;    req.r = bufr;    [req.method, req.url, req.proto] = firstLine.split(" ", 3);    [req.protoMajor, req.protoMinor] = parseHTTPVersion(req.proto);    req.headers = headers;    fixLength(req);    return req;}class Server {    listener;    #closing;    #connections;    constructor(listener){        this.listener = listener;        this.#closing = false;        this.#connections = [];    }    close() {        this.#closing = true;        this.listener.close();        for (const conn of this.#connections){            try {                conn.close();            } catch (e) {                if (!(e instanceof Deno.errors.BadResource)) {                    throw e;                }            }        }    }    async *iterateHttpRequests(conn) {        const reader = new BufReader(conn);        const writer = new BufWriter(conn);        while(!this.#closing){            let request;            try {                request = await readRequest(conn, reader);            } catch (error) {                if (error instanceof Deno.errors.InvalidData || error instanceof Deno.errors.UnexpectedEof) {                    try {                        await writeResponse(writer, {                            status: 400,                            body: new TextEncoder().encode(`${error.message}\r\n\r\n`)                        });                    } catch  {}                }                break;            }            if (request === null) {                break;            }            request.w = writer;            yield request;            const responseError = await request.done;            if (responseError) {                this.untrackConnection(request.conn);                return;            }            try {                await request.finalize();            } catch  {                break;            }        }        this.untrackConnection(conn);        try {            conn.close();        } catch  {}    }    trackConnection(conn) {        this.#connections.push(conn);    }    untrackConnection(conn) {        const index = this.#connections.indexOf(conn);        if (index !== -1) {            this.#connections.splice(index, 1);        }    }    async *acceptConnAndIterateHttpRequests(mux) {        if (this.#closing) return;        let conn;        try {            conn = await this.listener.accept();        } catch (error) {            if (error instanceof Deno.errors.BadResource || error instanceof Deno.errors.InvalidData || error instanceof Deno.errors.UnexpectedEof || error instanceof Deno.errors.ConnectionReset) {                return mux.add(this.acceptConnAndIterateHttpRequests(mux));            }            throw error;        }        this.trackConnection(conn);        mux.add(this.acceptConnAndIterateHttpRequests(mux));        yield* this.iterateHttpRequests(conn);    }    [Symbol.asyncIterator]() {        const mux = new MuxAsyncIterator();        mux.add(this.acceptConnAndIterateHttpRequests(mux));        return mux.iterate();    }}function _parseAddrFromStr(addr) {    let url;    try {        const host = addr.startsWith(":") ? `0.0.0.0${addr}` : addr;        url = new URL(`http://${host}`);    } catch  {        throw new TypeError("Invalid address.");    }    if (url.username || url.password || url.pathname != "/" || url.search || url.hash) {        throw new TypeError("Invalid address.");    }    return {        hostname: url.hostname,        port: url.port === "" ? 80 : Number(url.port)    };}function serve(addr) {    if (typeof addr === "string") {        addr = _parseAddrFromStr(addr);    }    const listener = Deno.listen(addr);    return new Server(listener);}function fixLength(req) {    const contentLength = req.headers.get("Content-Length");    if (contentLength) {        const arrClen = contentLength.split(",");        if (arrClen.length > 1) {            const distinct = [                ...new Set(arrClen.map((e)=>e.trim()))            ];            if (distinct.length > 1) {                throw Error("cannot contain multiple Content-Length headers");            } else {                req.headers.set("Content-Length", distinct[0]);            }        }        const c = req.headers.get("Content-Length");        if (req.method === "HEAD" && c && c !== "0") {            throw Error("http: method cannot contain a Content-Length");        }        if (c && req.headers.has("transfer-encoding")) {            throw new Error("http: Transfer-Encoding and Content-Length cannot be send together");        }    }}function hasOwnProperty(obj, v) {    if (obj == null) {        return false;    }    return Object.prototype.hasOwnProperty.call(obj, v);}async function readShort(buf) {    const high = await buf.readByte();    if (high === null) return null;    const low = await buf.readByte();    if (low === null) throw new Deno.errors.UnexpectedEof();    return high << 8 | low;}async function readInt(buf) {    const high = await readShort(buf);    if (high === null) return null;    const low = await readShort(buf);    if (low === null) throw new Deno.errors.UnexpectedEof();    return high << 16 | low;}const MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);async function readLong(buf) {    const high = await readInt(buf);    if (high === null) return null;    const low = await readInt(buf);    if (low === null) throw new Deno.errors.UnexpectedEof();    const big = BigInt(high) << 32n | BigInt(low);    if (big > MAX_SAFE_INTEGER) {        throw new RangeError("Long value too big to be represented as a JavaScript number.");    }    return Number(big);}function sliceLongToBytes(d, dest = new Array(8)) {    let big = BigInt(d);    for(let i = 0; i < 8; i++){        dest[7 - i] = Number(big & 0xffn);        big >>= 8n;    }    return dest;}const HEX_CHARS = "0123456789abcdef".split("");const EXTRA = [    -2147483648,    8388608,    32768,    128];const SHIFT = [    24,    16,    8,    0];const blocks = [];class Sha1 {    #blocks;    #block;    #start;    #bytes;    #hBytes;    #finalized;    #hashed;    #h0 = 0x67452301;    #h1 = 0xefcdab89;    #h2 = 0x98badcfe;    #h3 = 0x10325476;    #h4 = 0xc3d2e1f0;    #lastByteIndex = 0;    constructor(sharedMemory = false){        this.init(sharedMemory);    }    init(sharedMemory) {        if (sharedMemory) {            blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;            this.#blocks = blocks;        } else {            this.#blocks = [                0,                0,                0,                0,                0,                0,                0,                0,                0,                0,                0,                0,                0,                0,                0,                0,                0            ];        }        this.#h0 = 0x67452301;        this.#h1 = 0xefcdab89;        this.#h2 = 0x98badcfe;        this.#h3 = 0x10325476;        this.#h4 = 0xc3d2e1f0;        this.#block = this.#start = this.#bytes = this.#hBytes = 0;        this.#finalized = this.#hashed = false;    }    update(message) {        if (this.#finalized) {            return this;        }        let msg;        if (message instanceof ArrayBuffer) {            msg = new Uint8Array(message);        } else {            msg = message;        }        let index = 0;        const length = msg.length;        const blocks = this.#blocks;        while(index < length){            let i;            if (this.#hashed) {                this.#hashed = false;                blocks[0] = this.#block;                blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;            }            if (typeof msg !== "string") {                for(i = this.#start; index < length && i < 64; ++index){                    blocks[i >> 2] |= msg[index] << SHIFT[i++ & 3];                }            } else {                for(i = this.#start; index < length && i < 64; ++index){                    let code = msg.charCodeAt(index);                    if (code < 0x80) {                        blocks[i >> 2] |= code << SHIFT[i++ & 3];                    } else if (code < 0x800) {                        blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];                        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];                    } else if (code < 0xd800 || code >= 0xe000) {                        blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];                        blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];                        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];                    } else {                        code = 0x10000 + ((code & 0x3ff) << 10 | msg.charCodeAt(++index) & 0x3ff);                        blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];                        blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];                        blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];                        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];                    }                }            }            this.#lastByteIndex = i;            this.#bytes += i - this.#start;            if (i >= 64) {                this.#block = blocks[16];                this.#start = i - 64;                this.hash();                this.#hashed = true;            } else {                this.#start = i;            }        }        if (this.#bytes > 4294967295) {            this.#hBytes += this.#bytes / 4294967296 >>> 0;            this.#bytes = this.#bytes >>> 0;        }        return this;    }    finalize() {        if (this.#finalized) {            return;        }        this.#finalized = true;        const blocks = this.#blocks;        const i = this.#lastByteIndex;        blocks[16] = this.#block;        blocks[i >> 2] |= EXTRA[i & 3];        this.#block = blocks[16];        if (i >= 56) {            if (!this.#hashed) {                this.hash();            }            blocks[0] = this.#block;            blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;        }        blocks[14] = this.#hBytes << 3 | this.#bytes >>> 29;        blocks[15] = this.#bytes << 3;        this.hash();    }    hash() {        let a = this.#h0;        let b = this.#h1;        let c = this.#h2;        let d = this.#h3;        let e = this.#h4;        let f;        let j;        let t;        const blocks = this.#blocks;        for(j = 16; j < 80; ++j){            t = blocks[j - 3] ^ blocks[j - 8] ^ blocks[j - 14] ^ blocks[j - 16];            blocks[j] = t << 1 | t >>> 31;        }        for(j = 0; j < 20; j += 5){            f = b & c | ~b & d;            t = a << 5 | a >>> 27;            e = t + f + e + 1518500249 + blocks[j] >>> 0;            b = b << 30 | b >>> 2;            f = a & b | ~a & c;            t = e << 5 | e >>> 27;            d = t + f + d + 1518500249 + blocks[j + 1] >>> 0;            a = a << 30 | a >>> 2;            f = e & a | ~e & b;            t = d << 5 | d >>> 27;            c = t + f + c + 1518500249 + blocks[j + 2] >>> 0;            e = e << 30 | e >>> 2;            f = d & e | ~d & a;            t = c << 5 | c >>> 27;            b = t + f + b + 1518500249 + blocks[j + 3] >>> 0;            d = d << 30 | d >>> 2;            f = c & d | ~c & e;            t = b << 5 | b >>> 27;            a = t + f + a + 1518500249 + blocks[j + 4] >>> 0;            c = c << 30 | c >>> 2;        }        for(; j < 40; j += 5){            f = b ^ c ^ d;            t = a << 5 | a >>> 27;            e = t + f + e + 1859775393 + blocks[j] >>> 0;            b = b << 30 | b >>> 2;            f = a ^ b ^ c;            t = e << 5 | e >>> 27;            d = t + f + d + 1859775393 + blocks[j + 1] >>> 0;            a = a << 30 | a >>> 2;            f = e ^ a ^ b;            t = d << 5 | d >>> 27;            c = t + f + c + 1859775393 + blocks[j + 2] >>> 0;            e = e << 30 | e >>> 2;            f = d ^ e ^ a;            t = c << 5 | c >>> 27;            b = t + f + b + 1859775393 + blocks[j + 3] >>> 0;            d = d << 30 | d >>> 2;            f = c ^ d ^ e;            t = b << 5 | b >>> 27;            a = t + f + a + 1859775393 + blocks[j + 4] >>> 0;            c = c << 30 | c >>> 2;        }        for(; j < 60; j += 5){            f = b & c | b & d | c & d;            t = a << 5 | a >>> 27;            e = t + f + e - 1894007588 + blocks[j] >>> 0;            b = b << 30 | b >>> 2;            f = a & b | a & c | b & c;            t = e << 5 | e >>> 27;            d = t + f + d - 1894007588 + blocks[j + 1] >>> 0;            a = a << 30 | a >>> 2;            f = e & a | e & b | a & b;            t = d << 5 | d >>> 27;            c = t + f + c - 1894007588 + blocks[j + 2] >>> 0;            e = e << 30 | e >>> 2;            f = d & e | d & a | e & a;            t = c << 5 | c >>> 27;            b = t + f + b - 1894007588 + blocks[j + 3] >>> 0;            d = d << 30 | d >>> 2;            f = c & d | c & e | d & e;            t = b << 5 | b >>> 27;            a = t + f + a - 1894007588 + blocks[j + 4] >>> 0;            c = c << 30 | c >>> 2;        }        for(; j < 80; j += 5){            f = b ^ c ^ d;            t = a << 5 | a >>> 27;            e = t + f + e - 899497514 + blocks[j] >>> 0;            b = b << 30 | b >>> 2;            f = a ^ b ^ c;            t = e << 5 | e >>> 27;            d = t + f + d - 899497514 + blocks[j + 1] >>> 0;            a = a << 30 | a >>> 2;            f = e ^ a ^ b;            t = d << 5 | d >>> 27;            c = t + f + c - 899497514 + blocks[j + 2] >>> 0;            e = e << 30 | e >>> 2;            f = d ^ e ^ a;            t = c << 5 | c >>> 27;            b = t + f + b - 899497514 + blocks[j + 3] >>> 0;            d = d << 30 | d >>> 2;            f = c ^ d ^ e;            t = b << 5 | b >>> 27;            a = t + f + a - 899497514 + blocks[j + 4] >>> 0;            c = c << 30 | c >>> 2;        }        this.#h0 = this.#h0 + a >>> 0;        this.#h1 = this.#h1 + b >>> 0;        this.#h2 = this.#h2 + c >>> 0;        this.#h3 = this.#h3 + d >>> 0;        this.#h4 = this.#h4 + e >>> 0;    }    hex() {        this.finalize();        const h0 = this.#h0;        const h1 = this.#h1;        const h2 = this.#h2;        const h3 = this.#h3;        const h4 = this.#h4;        return HEX_CHARS[h0 >> 28 & 0x0f] + HEX_CHARS[h0 >> 24 & 0x0f] + HEX_CHARS[h0 >> 20 & 0x0f] + HEX_CHARS[h0 >> 16 & 0x0f] + HEX_CHARS[h0 >> 12 & 0x0f] + HEX_CHARS[h0 >> 8 & 0x0f] + HEX_CHARS[h0 >> 4 & 0x0f] + HEX_CHARS[h0 & 0x0f] + HEX_CHARS[h1 >> 28 & 0x0f] + HEX_CHARS[h1 >> 24 & 0x0f] + HEX_CHARS[h1 >> 20 & 0x0f] + HEX_CHARS[h1 >> 16 & 0x0f] + HEX_CHARS[h1 >> 12 & 0x0f] + HEX_CHARS[h1 >> 8 & 0x0f] + HEX_CHARS[h1 >> 4 & 0x0f] + HEX_CHARS[h1 & 0x0f] + HEX_CHARS[h2 >> 28 & 0x0f] + HEX_CHARS[h2 >> 24 & 0x0f] + HEX_CHARS[h2 >> 20 & 0x0f] + HEX_CHARS[h2 >> 16 & 0x0f] + HEX_CHARS[h2 >> 12 & 0x0f] + HEX_CHARS[h2 >> 8 & 0x0f] + HEX_CHARS[h2 >> 4 & 0x0f] + HEX_CHARS[h2 & 0x0f] + HEX_CHARS[h3 >> 28 & 0x0f] + HEX_CHARS[h3 >> 24 & 0x0f] + HEX_CHARS[h3 >> 20 & 0x0f] + HEX_CHARS[h3 >> 16 & 0x0f] + HEX_CHARS[h3 >> 12 & 0x0f] + HEX_CHARS[h3 >> 8 & 0x0f] + HEX_CHARS[h3 >> 4 & 0x0f] + HEX_CHARS[h3 & 0x0f] + HEX_CHARS[h4 >> 28 & 0x0f] + HEX_CHARS[h4 >> 24 & 0x0f] + HEX_CHARS[h4 >> 20 & 0x0f] + HEX_CHARS[h4 >> 16 & 0x0f] + HEX_CHARS[h4 >> 12 & 0x0f] + HEX_CHARS[h4 >> 8 & 0x0f] + HEX_CHARS[h4 >> 4 & 0x0f] + HEX_CHARS[h4 & 0x0f];    }    toString() {        return this.hex();    }    digest() {        this.finalize();        const h0 = this.#h0;        const h1 = this.#h1;        const h2 = this.#h2;        const h3 = this.#h3;        const h4 = this.#h4;        return [            h0 >> 24 & 0xff,            h0 >> 16 & 0xff,            h0 >> 8 & 0xff,            h0 & 0xff,            h1 >> 24 & 0xff,            h1 >> 16 & 0xff,            h1 >> 8 & 0xff,            h1 & 0xff,            h2 >> 24 & 0xff,            h2 >> 16 & 0xff,            h2 >> 8 & 0xff,            h2 & 0xff,            h3 >> 24 & 0xff,            h3 >> 16 & 0xff,            h3 >> 8 & 0xff,            h3 & 0xff,            h4 >> 24 & 0xff,            h4 >> 16 & 0xff,            h4 >> 8 & 0xff,            h4 & 0xff        ];    }    array() {        return this.digest();    }    arrayBuffer() {        this.finalize();        const buffer = new ArrayBuffer(20);        const dataView = new DataView(buffer);        dataView.setUint32(0, this.#h0);        dataView.setUint32(4, this.#h1);        dataView.setUint32(8, this.#h2);        dataView.setUint32(12, this.#h3);        dataView.setUint32(16, this.#h4);        return buffer;    }}var OpCode;(function(OpCode) {    OpCode[OpCode["Continue"] = 0x0] = "Continue";    OpCode[OpCode["TextFrame"] = 0x1] = "TextFrame";    OpCode[OpCode["BinaryFrame"] = 0x2] = "BinaryFrame";    OpCode[OpCode["Close"] = 0x8] = "Close";    OpCode[OpCode["Ping"] = 0x9] = "Ping";    OpCode[OpCode["Pong"] = 0xa] = "Pong";})(OpCode || (OpCode = {}));function isWebSocketCloseEvent(a) {    return hasOwnProperty(a, "code");}function isWebSocketPingEvent(a) {    return Array.isArray(a) && a[0] === "ping" && a[1] instanceof Uint8Array;}function isWebSocketPongEvent(a) {    return Array.isArray(a) && a[0] === "pong" && a[1] instanceof Uint8Array;}function unmask(payload, mask) {    if (mask) {        for(let i = 0, len = payload.length; i < len; i++){            payload[i] ^= mask[i & 3];        }    }}async function writeFrame(frame, writer) {    const payloadLength = frame.payload.byteLength;    let header;    const hasMask = frame.mask ? 0x80 : 0;    if (frame.mask && frame.mask.byteLength !== 4) {        throw new Error("invalid mask. mask must be 4 bytes: length=" + frame.mask.byteLength);    }    if (payloadLength < 126) {        header = new Uint8Array([            0x80 | frame.opcode,            hasMask | payloadLength        ]);    } else if (payloadLength < 0xffff) {        header = new Uint8Array([            0x80 | frame.opcode,            hasMask | 0b01111110,            payloadLength >>> 8,            payloadLength & 0x00ff        ]);    } else {        header = new Uint8Array([            0x80 | frame.opcode,            hasMask | 0b01111111,            ...sliceLongToBytes(payloadLength)        ]);    }    if (frame.mask) {        header = concat(header, frame.mask);    }    unmask(frame.payload, frame.mask);    header = concat(header, frame.payload);    const w = BufWriter.create(writer);    await w.write(header);    await w.flush();}async function readFrame(buf) {    let b = await buf.readByte();    assert(b !== null);    let isLastFrame = false;    switch(b >>> 4){        case 0b1000:            isLastFrame = true;            break;        case 0b0000:            isLastFrame = false;            break;        default:            throw new Error("invalid signature");    }    const opcode = b & 0x0f;    b = await buf.readByte();    assert(b !== null);    const hasMask = b >>> 7;    let payloadLength = b & 0b01111111;    if (payloadLength === 126) {        const l = await readShort(buf);        assert(l !== null);        payloadLength = l;    } else if (payloadLength === 127) {        const l = await readLong(buf);        assert(l !== null);        payloadLength = Number(l);    }    let mask;    if (hasMask) {        mask = new Uint8Array(4);        assert(await buf.readFull(mask) !== null);    }    const payload = new Uint8Array(payloadLength);    assert(await buf.readFull(payload) !== null);    return {        isLastFrame,        opcode,        mask,        payload    };}class WebSocketImpl {    conn;    mask;    bufReader;    bufWriter;    sendQueue = [];    constructor({ conn , bufReader , bufWriter , mask  }){        this.conn = conn;        this.mask = mask;        this.bufReader = bufReader || new BufReader(conn);        this.bufWriter = bufWriter || new BufWriter(conn);    }    async *[Symbol.asyncIterator]() {        const decoder = new TextDecoder();        let frames = [];        let payloadsLength = 0;        while(!this._isClosed){            let frame;            try {                frame = await readFrame(this.bufReader);            } catch  {                this.ensureSocketClosed();                break;            }            unmask(frame.payload, frame.mask);            switch(frame.opcode){                case OpCode.TextFrame:                case OpCode.BinaryFrame:                case OpCode.Continue:                    frames.push(frame);                    payloadsLength += frame.payload.length;                    if (frame.isLastFrame) {                        const concat = new Uint8Array(payloadsLength);                        let offs = 0;                        for (const frame of frames){                            concat.set(frame.payload, offs);                            offs += frame.payload.length;                        }                        if (frames[0].opcode === OpCode.TextFrame) {                            yield decoder.decode(concat);                        } else {                            yield concat;                        }                        frames = [];                        payloadsLength = 0;                    }                    break;                case OpCode.Close:                    {                        const code = frame.payload[0] << 8 | frame.payload[1];                        const reason = decoder.decode(frame.payload.subarray(2, frame.payload.length));                        await this.close(code, reason);                        yield {                            code,                            reason                        };                        return;                    }                case OpCode.Ping:                    await this.enqueue({                        opcode: OpCode.Pong,                        payload: frame.payload,                        isLastFrame: true                    });                    yield [                        "ping",                        frame.payload                    ];                    break;                case OpCode.Pong:                    yield [                        "pong",                        frame.payload                    ];                    break;                default:            }        }    }    dequeue() {        const [entry] = this.sendQueue;        if (!entry) return;        if (this._isClosed) return;        const { d , frame  } = entry;        writeFrame(frame, this.bufWriter).then(()=>d.resolve()).catch((e)=>d.reject(e)).finally(()=>{            this.sendQueue.shift();            this.dequeue();        });    }    enqueue(frame) {        if (this._isClosed) {            throw new Deno.errors.ConnectionReset("Socket has already been closed");        }        const d = deferred();        this.sendQueue.push({            d,            frame        });        if (this.sendQueue.length === 1) {            this.dequeue();        }        return d;    }    send(data) {        const opcode = typeof data === "string" ? OpCode.TextFrame : OpCode.BinaryFrame;        const payload = typeof data === "string" ? new TextEncoder().encode(data) : data;        const frame = {            isLastFrame: true,            opcode,            payload,            mask: this.mask        };        return this.enqueue(frame);    }    ping(data = "") {        const payload = typeof data === "string" ? new TextEncoder().encode(data) : data;        const frame = {            isLastFrame: true,            opcode: OpCode.Ping,            mask: this.mask,            payload        };        return this.enqueue(frame);    }    _isClosed = false;    get isClosed() {        return this._isClosed;    }    async close(code = 1000, reason) {        try {            const header = [                code >>> 8,                code & 0x00ff            ];            let payload;            if (reason) {                const reasonBytes = new TextEncoder().encode(reason);                payload = new Uint8Array(2 + reasonBytes.byteLength);                payload.set(header);                payload.set(reasonBytes, 2);            } else {                payload = new Uint8Array(header);            }            await this.enqueue({                isLastFrame: true,                opcode: OpCode.Close,                mask: this.mask,                payload            });        } catch (e) {            throw e;        } finally{            this.ensureSocketClosed();        }    }    closeForce() {        this.ensureSocketClosed();    }    ensureSocketClosed() {        if (this.isClosed) return;        try {            this.conn.close();        } catch (e) {            console.error(e);        } finally{            this._isClosed = true;            const rest = this.sendQueue;            this.sendQueue = [];            rest.forEach((e)=>e.d.reject(new Deno.errors.ConnectionReset("Socket has already been closed")));        }    }}function acceptable(req) {    const upgrade = req.headers.get("upgrade");    if (!upgrade || upgrade.toLowerCase() !== "websocket") {        return false;    }    const secKey = req.headers.get("sec-websocket-key");    return req.headers.has("sec-websocket-key") && typeof secKey === "string" && secKey.length > 0;}const kGUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";function createSecAccept(nonce) {    const sha1 = new Sha1();    sha1.update(nonce + kGUID);    const bytes = sha1.digest();    return btoa(String.fromCharCode(...bytes));}async function acceptWebSocket(req) {    const { conn , headers , bufReader , bufWriter  } = req;    if (acceptable(req)) {        const sock = new WebSocketImpl({            conn,            bufReader,            bufWriter        });        const secKey = headers.get("sec-websocket-key");        if (typeof secKey !== "string") {            throw new Error("sec-websocket-key is not provided");        }        const secAccept = createSecAccept(secKey);        const newHeaders = new Headers({            Upgrade: "websocket",            Connection: "Upgrade",            "Sec-WebSocket-Accept": secAccept        });        const secProtocol = headers.get("sec-websocket-protocol");        if (typeof secProtocol === "string") {            newHeaders.set("Sec-WebSocket-Protocol", secProtocol);        }        const secVersion = headers.get("sec-websocket-version");        if (typeof secVersion === "string") {            newHeaders.set("Sec-WebSocket-Version", secVersion);        }        await writeResponse(bufWriter, {            status: 101,            headers: newHeaders        });        return sock;    }    throw new Error("request is not acceptable");}class WebSocketError extends Error {    constructor(e){        super(e);        Object.setPrototypeOf(this, WebSocketError.prototype);    }}var WebSocketState;(function(WebSocketState) {    WebSocketState[WebSocketState["CONNECTING"] = 0] = "CONNECTING";    WebSocketState[WebSocketState["OPEN"] = 1] = "OPEN";    WebSocketState[WebSocketState["CLOSING"] = 2] = "CLOSING";    WebSocketState[WebSocketState["CLOSED"] = 3] = "CLOSED";})(WebSocketState || (WebSocketState = {}));class GenericEventEmitter extends EventEmitter {    on(...params) {        return super.on(...params);    }    emit(...params) {        return super.emit(...params);    }}class WebSocketServer extends GenericEventEmitter {    port;    realIpHeader;    clients;    server;    constructor(port = 8080, realIpHeader = null){        super();        this.port = port;        this.realIpHeader = realIpHeader;        this.clients = new Set();        this.server = undefined;        this.connect();    }    async connect() {        this.server = serve(`:${this.port}`);        for await (const req of this.server){            const { conn , r: bufReader , w: bufWriter , headers  } = req;            try {                const sock = await acceptWebSocket({                    conn,                    bufReader,                    bufWriter,                    headers                });                if (this.realIpHeader && "hostname" in sock.conn.remoteAddr) {                    if (!req.headers.has(this.realIpHeader)) {                        this.emit("error", new Error("specified real ip header does not exist"));                    } else {                        sock.conn.remoteAddr.hostname = req.headers.get(this.realIpHeader) || sock.conn.remoteAddr.hostname;                    }                }                const ws = new WebSocketAcceptedClient(sock);                this.clients.add(ws);                this.emit("connection", ws, req.url);            } catch (err) {                this.emit("error", err);                await req.respond({                    status: 400                });            }        }    }    async close() {        this.server?.close();        this.clients.clear();    }}class WebSocketAcceptedClient extends GenericEventEmitter {    state = WebSocketState.CONNECTING;    webSocket;    constructor(sock){        super();        this.webSocket = sock;        this.open();    }    async open() {        this.state = WebSocketState.OPEN;        this.emit("open");        try {            for await (const ev of this.webSocket){                if (typeof ev === "string") {                    this.emit("message", ev);                } else if (ev instanceof Uint8Array) {                    this.emit("message", ev);                } else if (isWebSocketPingEvent(ev)) {                    const [, body] = ev;                    this.emit("ping", body);                } else if (isWebSocketPongEvent(ev)) {                    const [, body] = ev;                    this.emit("pong", body);                } else if (isWebSocketCloseEvent(ev)) {                    const { code , reason  } = ev;                    this.state = WebSocketState.CLOSED;                    this.emit("close", code);                }            }        } catch (err) {            this.emit("close", err);            if (!this.webSocket.isClosed) {                await this.webSocket.close(1000).catch((e)=>{                    if (this.state === WebSocketState.CLOSING && this.webSocket.isClosed) {                        this.state = WebSocketState.CLOSED;                        return;                    }                    throw new WebSocketError(e);                });            }        }    }    async ping(message) {        if (this.state === WebSocketState.CONNECTING) {            throw new WebSocketError("WebSocket is not open: state 0 (CONNECTING)");        }        return this.webSocket.ping(message);    }    async send(message) {        try {            if (this.state === WebSocketState.CONNECTING) {                throw new WebSocketError("WebSocket is not open: state 0 (CONNECTING)");            }            return this.webSocket.send(message);        } catch (error) {            this.state = WebSocketState.CLOSED;            this.emit("close", error.message);        }    }    async close(code = 1000, reason) {        if (this.state === WebSocketState.CLOSING || this.state === WebSocketState.CLOSED) {            return;        }        this.state = WebSocketState.CLOSING;        return this.webSocket.close(code, reason);    }    async closeForce() {        if (this.state === WebSocketState.CLOSING || this.state === WebSocketState.CLOSED) {            return;        }        this.state = WebSocketState.CLOSING;        return this.webSocket.closeForce();    }    get isClosed() {        return this.webSocket.isClosed;    }}function Memory(state) {    if (typeof state !== 'object') {        state = {};    }    var _this = this;    try {        _this = super_constructor(this, Memory, state);    } catch (e) {        console.error();        _this.assign(state);    }    return _this;}Memory.prototype.valueOf = function() {    return Object.assign({}, this);};Object.setPrototypeOf(Memory.prototype, Object);const base64abc = [    "A",    "B",    "C",    "D",    "E",    "F",    "G",    "H",    "I",    "J",    "K",    "L",    "M",    "N",    "O",    "P",    "Q",    "R",    "S",    "T",    "U",    "V",    "W",    "X",    "Y",    "Z",    "a",    "b",    "c",    "d",    "e",    "f",    "g",    "h",    "i",    "j",    "k",    "l",    "m",    "n",    "o",    "p",    "q",    "r",    "s",    "t",    "u",    "v",    "w",    "x",    "y",    "z",    "0",    "1",    "2",    "3",    "4",    "5",    "6",    "7",    "8",    "9",    "+",    "/"];function encode(data) {    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);    let result = "", i;    const l = uint8.length;    for(i = 2; i < l; i += 3){        result += base64abc[uint8[i - 2] >> 2];        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];        result += base64abc[uint8[i] & 0x3f];    }    if (i === l + 1) {        result += base64abc[uint8[i - 2] >> 2];        result += base64abc[(uint8[i - 2] & 0x03) << 4];        result += "==";    }    if (i === l) {        result += base64abc[uint8[i - 2] >> 2];        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];        result += base64abc[(uint8[i - 1] & 0x0f) << 2];        result += "=";    }    return result;}function decode(b64) {    const binString = atob(b64);    const size = binString.length;    const bytes = new Uint8Array(size);    for(let i = 0; i < size; i++){        bytes[i] = binString.charCodeAt(i);    }    return bytes;}function Buffer(ab) {    this.buffer = new DataView(ab);    this.length = this.buffer.byteLength;}Buffer.prototype.readUInt8 = function(offset) {    return this.buffer.getUint8(offset);};Buffer.prototype.readUInt16LE = function(offset) {    return this.buffer.getUint16(offset, true);};Buffer.prototype.readUInt16BE = function(offset) {    return this.buffer.getUint16(offset, false);};Buffer.prototype.readUInt32LE = function(offset) {    return this.buffer.getUint32(offset, true);};Buffer.prototype.readInt32LE = function(offset) {    return this.buffer.getInt32(offset, true);};Buffer.prototype.readUInt32BE = function(offset) {    return this.buffer.getUint32(offset, false);};Buffer.prototype.writeUInt32LE = function(n, offset) {    this.buffer.setUint32(offset, n, true);};Buffer.prototype.slice = function(start, end) {    return new Buffer(this.buffer.buffer.slice(start, end));};Buffer.prototype.toString = function(enc) {    if (!enc) enc = 'utf8';    if (enc == 'utf8') {        return new TextDecoder().decode(this.buffer.buffer);    }    if (enc == 'base64') {        return encode(this.buffer.buffer);    }    throw new Error('Unsupported encoding');};Buffer.prototype.arrayBuffer = function() {    return this.buffer.buffer;};Buffer.alloc = function(n) {    return new Buffer(new ArrayBuffer(n));};Buffer.from = function(s, enc) {    if (s instanceof Buffer) {        return new Buffer(s.buffer.buffer.slice(0));    }    if (s instanceof Array) {        return new Buffer(new Uint8Array(s).buffer);    }    s = s.toString();    if (enc == 'base64') {        try {            var a = decode(s);            var b = new Buffer(a.buffer);            return b;        } catch (e) {            console.error(e);            enc = 'ascii';        }    }    var b = new Uint8Array(s.length);    for(var i = 0; i < s.length; i++){        b[i] = s.charCodeAt(i);    }    return new Buffer(b.buffer);};Buffer.concat = function(buffers) {    var out = new Uint8Array(buffers.reduce((acc, b)=>acc + b.length, 0));    var offset = 0;    for(var i = 0; i < buffers.length; i++){        out.set(new Uint8Array(buffers[i].buffer.buffer), offset);        offset += buffers[i].length;    }    return new Buffer(out.buffer);};var PICKLE_OP_NAMES = {    MARK: '(',    STOP: '.',    POP: '0',    POP_MARK: '1',    DUP: '2',    FLOAT: 'F',    INT: 'I',    BININT: 'J',    BININT1: 'K',    LONG: 'L',    BININT2: 'M',    NONE: 'N',    PERSID: 'P',    BINPERSID: 'Q',    REDUCE: 'R',    STRING: 'S',    BINSTRING: 'T',    SHORT_BINSTRING: 'U',    UNICODE: 'V',    BINUNICODE: 'X',    APPEND: 'a',    BUILD: 'b',    GLOBAL: 'c',    DICT: 'd',    EMPTY_DICT: '}',    APPENDS: 'e',    GET: 'g',    BINGET: 'h',    INST: 'i',    LONG_BINGET: 'j',    LIST: 'l',    EMPTY_LIST: ']',    OBJ: 'o',    PUT: 'p',    BINPUT: 'q',    LONG_BINPUT: 'r',    SETITEM: 's',    TUPLE: 't',    EMPTY_TUPLE: ')',    SETITEMS: 'u',    PROTO: '\x80',    NEWOBJ: '\x81',    TUPLE1: '\x85',    TUPLE2: '\x86',    TUPLE3: '\x87',    NEWTRUE: '\x88',    NEWFALSE: '\x89',    LONG1: '\x8a',    LONG4: '\x8b',    BINBYTES: 'B',    SHORT_BINBYTES: 'C'};var PICKLE_OP_VALUES = {};for(var k in PICKLE_OP_NAMES){    PICKLE_OP_VALUES[PICKLE_OP_NAMES[k]] = k;}var PICKLE_OP_BYTES = {};for(var k in PICKLE_OP_NAMES){    let v = PICKLE_OP_NAMES[k].charCodeAt(0);    PICKLE_OP_BYTES[k] = Buffer.from([        v    ]);}var PICKLE_GLOBAL_SCOPE = {};function List(args) {    var _this = this;    _this = super_constructor(this, List, ...args);    return _this;}Object.setPrototypeOf(List.prototype, Array.prototype);PICKLE_GLOBAL_SCOPE['builtins.list'] = List;function PythonObject(args) {    var _this = this;    _this = super_constructor(this, PythonObject, {});    return _this;}Object.setPrototypeOf(PythonObject.prototype, Memory.prototype);PICKLE_GLOBAL_SCOPE['builtins.Object'] = PythonObject;function Dict(args) {    var _this = this;    _this = super_constructor(this, Dict, args);    return _this;}Object.setPrototypeOf(Dict.prototype, PythonObject.prototype);PICKLE_GLOBAL_SCOPE['builtins.dict'] = Dict;function Exception(args) {    var _this = this;    _this = super_constructor(this, Exception, args);    return _this;}Object.setPrototypeOf(Exception.prototype, PythonObject.prototype);PICKLE_GLOBAL_SCOPE['builtins.Exception'] = Exception;const PORT = 8080;const ROOT = "/";function Pickler(obj) {    var _this = this;    _this = super_constructor(this, Pickler);    _this.obj = obj;    _this._pickle_impl();    return _this;}Object.setPrototypeOf(Pickler.prototype, PythonObject.prototype);PICKLE_GLOBAL_SCOPE['pickle.Pickler'] = Pickler;Pickler.prototype._pickle_impl = function() {    var buf = Buffer.concat([        O.PROTO,        Buffer.from([            3        ]),        Pickler._pickle_value(this.obj),        O.STOP    ]);    this.result = buf.toString('base64');};Pickler.pickle = function(obj) {    return new Pickler(obj).result;};var O = PICKLE_OP_BYTES;function little_endian_uint32(n) {    var b = Buffer.alloc(4);    b.writeUInt32LE(n, 0);    return b;}Pickler._pickle_value = function(v) {    if (v === null || v === undefined) {        return O.NONE;    }    if (typeof v == 'function') {        return Buffer.from([]);    }    if (typeof v == 'number') {        return Buffer.concat([            O.LONG1,            Buffer.from([                4            ]),            little_endian_uint32(v)        ]);    }    if (typeof v == 'string') {        if (v.length < 256) {            return Buffer.concat([                O.SHORT_BINSTRING,                Buffer.from([                    v.length                ]),                Buffer.from(v, 'utf8')            ]);        }        return Buffer.concat([            O.BINSTRING,            little_endian_uint32(v.length),            Buffer.from(v, 'utf8')        ]);    }    return v.__pickle__();};Object.prototype.__pickle__ = function() {    if (Array.isArray(this)) {        return Array.prototype.__pickle__.call(this);    }    var out = [        O.MARK    ];    for(var k in this){        if (!this.hasOwnProperty(k)) {            continue;        }        let kp = Pickler._pickle_value(k);        if (kp.length == 0) {            continue;        }        var v = this[k];        var vp = Pickler._pickle_value(v);        if (vp.length == 0) {            continue;        }        out.push(kp);        out.push(vp);    }    out.push(O.DICT);    return Buffer.concat(out);};Array.prototype.__pickle__ = function() {    var out = [        O.MARK    ];    for(var i = 0; i < this.length; i++){        var v = this[i];        out.push(Pickler._pickle_value(v));    }    out.push(O.LIST);    return Buffer.concat(out);};PythonObject.prototype.__pickle__ = function() {    var out = [        O.GLOBAL    ];    for(var k in PICKLE_GLOBAL_SCOPE){        var v = PICKLE_GLOBAL_SCOPE[k];        if (v === this.constructor) {            var namespace = k.split('.')[0];            var name = k.split('.')[1];            out.push(Buffer.from(namespace + '\n', 'utf8'));            out.push(Buffer.from(name + '\n', 'utf8'));            break;        }    }    if (out.length == 1) {        return Object.prototype.__pickle__.call(this);    }    out.push(O.EMPTY_TUPLE, O.NEWOBJ);    let props = Object.prototype.__pickle__.call(this);    out.push(props);    out.push(O.BUILD);    return Buffer.concat(out);};function Unpickler(p, enc) {    var _this = this;    _this = super_constructor(this, Unpickler, p);    _this.pickle = p;    _this.ind = 0;    _this.buffer = Buffer.from(p, enc);    _this.stack = [];    _this.mark_stack = [];    _this.result = _this._unpickle_impl();    return _this;}Object.setPrototypeOf(Unpickler.prototype, Memory.prototype);PICKLE_GLOBAL_SCOPE['pickle.Unpickler'] = Unpickler;PICKLE_GLOBAL_SCOPE['datetime.datetime'] = function(bin, tz) {    var tmp = new Buffer(bin.buffer, 'binary');    var year = tmp.readUInt16BE(0);    var month = tmp.readUInt8(2) - 1;    var day = tmp.readUInt8(3);    var hour = tmp.readUInt8(4);    var minute = tmp.readUInt8(5);    var second = tmp.readUInt8(6);    var microsecond = tmp.readUInt32BE(6) & 0xffffff;    if (tz == 'UTC') {        return new Date(Date.UTC(year, month, day, hour, minute, second, microsecond / 1000));    } else {        return new Date(year, month, day, hour, minute, second, microsecond / 1000);    }};Unpickler.unpickle = function(s, enc) {    return new Unpickler(s, enc).result;};Object.assign(Unpickler.prototype, {    _pop () {        var res = this.stack.pop();        try {        } catch (e) {        }        for(var i = this.mark_stack.length - 1; i >= 0; i--){            if (this.mark_stack[i] <= this.stack.length) {                this.mark_stack.splice(i + 1);                break;            }        }        this._dump_stack();        return res;    },    _peek () {        var res = this.stack[this.stack.length - 1];        try {        } catch (e) {        }        return res;    },    _dump_stack () {        let s = this.stack.slice(0).reverse();        for(let i = 0; i < s.length; i++){            let v = s[i];            try {            } catch (e) {            }        }    },    _push (v) {        try {        } catch (e) {        }        this.stack.push(v);        this._dump_stack();    },    _pushAll (a) {        for(var i = 0; i < a.length; i++){            this._push(a[i]);        }    },    _mark () {        this.mark_stack.push(this.stack.length);    },    _collect_since_marker () {        if (this.mark_stack.length == 0) {            return [];        }        let start = this.mark_stack.pop();        let res = this.stack.splice(start);        this._dump_stack();        return res;    },    _setItems (obj, items) {        for(var i = 0; i < items.length; i += 2){            var key = items[i];            var value = items[i + 1];            obj[key] = value;        }    },    _long (l) {        var s = 0;        for(var i = 0; i < l; i++){            let b = this._readu8();            s += b * Math.pow(256, i);        }        return s;    },    _readchar () {        let u8 = this._readu8();        return String.fromCharCode(u8);    },    _readu8 () {        var res = this.buffer.readUInt8(this.ind);        this.ind++;        return res;    },    _readu16 () {        var res = this.buffer.readUInt16LE(this.ind);        this.ind += 2;        return res;    },    _read32 () {        var res = this.buffer.readInt32LE(this.ind);        this.ind += 4;        return res;    },    _readu32 () {        var res = this.buffer.readUInt32LE(this.ind);        this.ind += 4;        return res;    },    _getUtf8Range (start, end) {        var slice = this.buffer.slice(start, end);        var res = slice.toString();        return res;    },    _getByteRange (start, end) {        var slice = this.buffer.slice(start, end);        return new Uint8Array(slice.arrayBuffer());    },    _getUtf8 (len) {        var res = this._getUtf8Range(this.ind, this.ind + len);        this.ind += len;        return res;    },    _getBytes (len) {        var res = this._getByteRange(this.ind, this.ind + len);        this.ind += len;        return res;    },    _readline () {        var start = this.ind;        while(this._readu8() != 0xa){}        var end = this.ind;        return this._getUtf8Range(start, end - 1);    }});Unpickler.prototype._unpickle_impl = function() {    for(; this.ind < this.buffer.length;){        var opcode = this._readu8();        var opcode_char = String.fromCharCode(opcode);        var op_name = PICKLE_OP_VALUES[opcode_char];        if (!op_name) {            throw new Error(`Unknown opcode: \`${opcode.toString(16)}\``);        }        if (op_name == 'STOP') {            break;        }        this._handle_opcode(op_name);    }    if (this.stack.length == 0) {        throw new Error('No object on stack after pickle STOP opcode');    }    var res = this._pop();    if (res === undefined) {        throw new Error('No object on stack after pickle STOP opcode');    }    return res;};Unpickler.prototype._handle_opcode = function(opcode) {    if (opcode == 'PROTO') {        var proto = this._readu8();        if (proto != 2 && proto != 3) {            throw new Error(`Unsupported pickle protocol: ${proto}`);        }    } else if (opcode == 'TUPLE1') {        this._push([            this._pop()        ]);    } else if (opcode == 'TUPLE2') {        this._push([            this._pop(),            this._pop()        ].reverse());    } else if (opcode == 'TUPLE3') {        this._push([            this._pop(),            this._pop(),            this._pop()        ].reverse());    } else if (opcode == 'NEWTRUE') {        this._push(true);    } else if (opcode == 'NEWFALSE') {        this._push(false);    } else if (opcode == 'NONE') {        this._push(null);    } else if (opcode == 'INT') {        var i = this._readline();        this._push(parseInt(i));    } else if (opcode == 'BININT') {        var i = this._read32();        this._push(i);    } else if (opcode == 'BININT1') {        var i = this._readu8();        this._push(i);    } else if (opcode == 'BININT2') {        var i = this._readu16();        this._push(i);    } else if (opcode == 'LONG1') {        var l = this._readu8();        this._push(this._long(l));    } else if (opcode == 'LONG4') {        var l = this._readu32();        this._push(this._long(l));    } else if (opcode == 'POP') {        this._pop();    } else if (opcode == 'DUP') {        let v = this._peek();        this._push(v);    } else if (opcode == 'EMPTY_LIST' || opcode == 'EMPTY_TUPLE') {        this._push([]);    } else if (opcode == 'EMPTY_DICT') {        this._push({});    } else if (opcode == 'MARK') {        this._mark();    } else if (opcode == 'POP_MARK') {        this._collect_since_marker();    } else if (opcode == 'GET') {        let key = this._readline();        this._push(this[key]);    } else if (opcode == 'BINGET') {        let key = this._readu8();        this._push(this[key]);    } else if (opcode == 'LONG_BINGET') {        let key = this._readu32();        this._push(this[key]);    } else if (opcode == 'PUT') {        let key = this._readline();        let val = this._peek();        this[key] = val;    } else if (opcode == 'BINPUT') {        let key = this._readu8();        let val = this._peek();        this[key] = val;    } else if (opcode == 'LONG_BINPUT') {        let key = this._readu32();        let val = this._peek();        this[key] = val;    } else if (opcode == 'UNICODE') {        var val = this._readline();        this._push(val);    } else if (opcode == 'SHORT_BINUNICODE') {        var len = this._readu8();        this._push(this._getUtf8(len));    } else if (opcode == 'BINUNICODE') {        var len = this._readu32();        this._push(this._getUtf8(len));    } else if (opcode == 'BINSTRING') {        var len = this._readu32();        this._push(this._getUtf8(len));    } else if (opcode == 'SHORT_BINSTRING') {        var len = this._readu8();        this._push(this._getUtf8(len));    } else if (opcode == 'NEWOBJ') {        var args = this._pop();        var constructor = this._pop();        this._push(new constructor(args));    } else if (opcode == 'REDUCE') {        var args = this._pop();        var constructor = this._pop();        this._push(constructor(args));    } else if (opcode == 'BUILD') {        var args = this._pop();        var obj = this._peek();        for(var k in args){            obj[k] = args[k];        }    } else if (opcode == 'DICT') {        var items = this._collect_since_marker();        var obj = {};        this._setItems(obj, items);        this._push(obj);    } else if (opcode == 'OBJ') {        var items = this._collect_since_marker();        var constructor = items.splice(0, 1)[0];        var obj = this.create(constructor.prototype);        this._setItems(obj, items);        this._push(obj);    } else if (opcode == 'SETITEM') {        var value = this._pop();        var key = this._pop();        var obj = this._peek();        obj[key] = value;    } else if (opcode == 'SETITEMS') {        var items = this._collect_since_marker();        var obj = this._peek();        this._setItems(obj, items);    } else if (opcode == 'LIST' || opcode == 'TUPLE') {        var items = this._collect_since_marker();        this._push(items);    } else if (opcode == 'APPEND') {        var val = this._pop();        var list = this._peek();        list.push(val);    } else if (opcode == 'APPENDS') {        var items = this._collect_since_marker();        var list = this._peek();        list.push.apply(list, items);    } else if (opcode == 'GLOBAL') {        var module = this._readline();        var name = this._readline();        var g = PICKLE_GLOBAL_SCOPE[module + '.' + name];        if (g == undefined) {            throw new Error(`Unknown global: ${module}.${name}`);        }        this._push(g);    } else if (opcode == 'SHORT_BINBYTES') {        var len = this._readu8();        this._push(this._getBytes(len));    } else if (opcode == 'BINBYTES') {        var len = this._readu32();        this._push(this._getBytes(len));    } else {        throw new Error(`Unsupported opcode: ${opcode}`);    }};class PickleWebsocket {    constructor(ws){        this.ws = ws;    }    send(obj) {        const out = Pickler.pickle(obj);        this.ws.send(out);    }    process(message) {        let struct = Unpickler.unpickle(message, 'base64');        if (struct instanceof Message) {            struct = struct.body;        }        if (struct instanceof Request) {            struct.process(this);        } else {            this.send(Exception([                "Invalid request"            ]));        }    }    ws;}function Message(args) {    var _this = super_constructor(this, Message, args);    _this.sender = args[0];    _this.body = args[1];    return _this;}Object.setPrototypeOf(Message.prototype, PythonObject.prototype);PICKLE_GLOBAL_SCOPE['__main__.Message'] = Message;function Request(args) {    var _this = super_constructor(this, Request, args);    return _this;}Object.setPrototypeOf(Request.prototype, PythonObject.prototype);PICKLE_GLOBAL_SCOPE['__main__.Request'] = Request;Request.prototype.process = function(ws) {    ws.send(Exception([        "Not implemented"    ]));};function Response(args) {    var _this = super_constructor(this, Response, args);    return _this;}Object.setPrototypeOf(Response.prototype, PythonObject.prototype);PICKLE_GLOBAL_SCOPE['__main__.Response'] = Response;Response.prototype.send = function(pws) {    pws.send(Message([        'server',        this    ]));};async function get_current_auction() {    try {        let prop_index = await Deno.readTextFile(`${ROOT}/properties/auction/index.json`);        prop_index = JSON.parse(prop_index);        let current_time = Math.floor(+Date.now() / 1000 / 120);        let end_time = (current_time + 1) * 120;        let current_index = current_time % prop_index.length;        let current_lot_name = prop_index[current_index];        let current_lot = await Deno.readTextFile(`${ROOT}/properties/auction/${current_lot_name}`);        current_lot = JSON.parse(current_lot);        current_lot.end_time = end_time;        let top = Number(BigInt('0x' + current_lot.secret) % 11n) / 10.0;        let high_price = Math.floor(current_lot.sell_price * (1.5 + top));        current_lot.description += ` Price range: < ${format_currency(high_price)}`;        return current_lot;    } catch (e) {        console.error(e);        return null;    }}async function get_current_balance() {    try {        const current_lot = await Deno.readTextFile(`${ROOT}/wallet/balance.json`);        return JSON.parse(current_lot);    } catch (e) {        console.error(e);        throw e;        return {            sanddollars: 0        };    }}async function get_loans() {    try {        let loans = await Deno.readTextFile(`${ROOT}/wallet/loans.json`);        loans = JSON.parse(loans);        for (let loan of loans){            let time_since = Date.now() - loan.time;            let periods = time_since / (60.0 * 60.0);            let n = 60.0;            let rate = loan.rate;            loan.with_intrest = loan.amount * Math.pow(1 + rate / n, n * periods);        }        return loans;    } catch (e) {        return [];    }}async function get_old_bid() {    try {        const old_bid = await Deno.readTextFile(`${ROOT}/wallet/current_bid.json`);        return JSON.parse(old_bid);    } catch (e) {        return null;    }}async function make_new_bid(uuid, val, tries) {    try {        let obj = {            bid: val,            uuid: uuid,            count: tries        };        let obj_j = JSON.stringify(obj);        await Deno.writeTextFile(`${ROOT}/wallet/current_bid.json`, obj_j);        return true;    } catch (e) {        console.error(e);        return false;    }}async function copy_property(uuid) {    try {        await Deno.copyFile(`${ROOT}/properties/auction/${uuid}.token`, `${ROOT}/wallet/properties/${uuid}.token`);        return true;    } catch (e) {        console.error(e);        return false;    }}async function update_balance(val) {    try {        val = JSON.stringify(val);        await Deno.writeTextFile(`${ROOT}/wallet/balance.json`, val);        return true;    } catch (e) {        return false;    }}async function submit_bid(val) {    val = ~~val;    if (isNaN(val) || val < 0 || val > 1000000000) {        return [            false,            'Sorry you did not get this property... Your bid is not valid.',            null        ];    }    let balance = await get_current_balance();    if (balance.sanddollars < val) {        return [            false,            'Sorry you did not get this property... You do not have enough money.',            null        ];    }    let current_lot = await get_current_auction();    let old_bid = await get_old_bid();    let bid_tries = 0;    if (old_bid && old_bid.uuid == current_lot.uuid) {        bid_tries = old_bid.count;        if (bid_tries >= 2) {            return [                false,                'Sorry you can only bid 2 times per property.',                null            ];        }    }    if (current_lot.floor_price > val) {        bid_tries++;    } else {        bid_tries = 100;    }    if (!await make_new_bid(current_lot.uuid, val, bid_tries)) {        return [            false,            'Sorry you did not get this property... There was an error writing your bid.',            null        ];    }    if (current_lot.floor_price > val) {        if (bid_tries >= 2) {            let min = current_lot.floor_price;            let max = current_lot.sell_price;            let winning_bid = Math.floor(Math.random() * (max - min + 1) + min);            return [                false,                `Sorry you did not get this property... Your bid is too low. The property sold for ${format_currency(winning_bid)} SandDollars.\nTry again next time`,                null            ];        } else {            return [                false,                `Sorry you did not get this property... Your bid is too low. You have ${2 - bid_tries} bid attempt left`,                null            ];        }    }    let new_balance = balance.sanddollars - val;    if (!await update_balance({        sanddollars: new_balance    })) {        return [            false,            'Sorry you did not get this property... There was an error updating your balance.',            null        ];    }    if (!await copy_property(current_lot.uuid)) {        return [            false,            'Sorry you did not get this property... There was an error transfering the property to you.',            null        ];    }    return [        true,        `Congratulations you bought the property for ${format_currency(val)} SandDollars! Estimated property value ~${format_currency(current_lot.sell_price)}`,        current_lot    ];}function AuctionProperty(args) {    var _this = this;    _this = super_constructor(this, AuctionProperty, args);    _this.uuid = args[0];    _this.property_name = args[1];    _this.description = args[2];    _this.end_time = args[3];    return _this;}Object.setPrototypeOf(AuctionProperty.prototype, PythonObject.prototype);PICKLE_GLOBAL_SCOPE['__main__.AuctionProperty'] = AuctionProperty;function PropertyToken(args) {    var _this = this;    _this = super_constructor(this, PropertyToken, args);    _this.uuid = args[0];    _this.property_name = args[1];    _this.description = args[2];    _this.estimated_value = args[3];    return _this;}Object.setPrototypeOf(PropertyToken.prototype, PythonObject.prototype);PICKLE_GLOBAL_SCOPE['__main__.PropertyToken'] = PropertyToken;function AuctionInfoRequest(args) {    var _this = this;    _this = super_constructor(this, AuctionInfoRequest, args);    return _this;}Object.setPrototypeOf(AuctionInfoRequest.prototype, Request.prototype);PICKLE_GLOBAL_SCOPE['__main__.AuctionInfoRequest'] = AuctionInfoRequest;AuctionInfoRequest.prototype.process = async function(ws) {    const current_lot = await get_current_auction();    let resp;    if (current_lot) {        resp = AuctionInfoResponse([            current_lot.uuid,            current_lot.name,            current_lot.description,            current_lot.end_time        ]);    } else {        resp = AuctionInfoResponse([]);    }    resp.send(ws);};function AuctionInfoResponse(args) {    var _this = this;    _this = super_constructor(this, AuctionInfoResponse, args);    if (args.length > 0) _this.property = AuctionProperty(args);    else _this.property = null;    return _this;}Object.setPrototypeOf(AuctionInfoResponse.prototype, Response.prototype);PICKLE_GLOBAL_SCOPE['__main__.AuctionInfoResponse'] = AuctionInfoResponse;function AuctionBidRequest(args) {    var _this = this;    _this = super_constructor(this, AuctionBidRequest, args);    _this.bid = args[0];    return _this;}Object.setPrototypeOf(AuctionBidRequest.prototype, Request.prototype);PICKLE_GLOBAL_SCOPE['__main__.AuctionBidRequest'] = AuctionBidRequest;AuctionBidRequest.prototype.process = async function(ws) {    let [res, msg, prop] = await submit_bid(this.bid);    let resp;    if (res) {        resp = AuctionBidResponse([            true,            msg,            prop.uuid,            prop.name,            prop.description,            prop.sell_price        ]);    } else {        resp = AuctionBidResponse([            false,            msg        ]);    }    resp.send(ws);};function AuctionBidResponse(args) {    var _this = this;    _this = super_constructor(this, AuctionBidResponse, args);    _this.success = args[0];    _this.message = args[1];    if (args.length > 2) _this.property = AuctionProperty(args.slice(2));    else _this.property = null;    return _this;}Object.setPrototypeOf(AuctionBidResponse.prototype, Response.prototype);PICKLE_GLOBAL_SCOPE['__main__.AuctionBidResponse'] = AuctionBidResponse;function auction_init() {}async function get_owned_properties() {    try {        const ents = await Deno.readDir(`${ROOT}/wallet/properties/`);        let props = [];        for await (const ent of ents){            const prop = await Deno.readTextFile(`${ROOT}/wallet/properties/${ent.name}`);            let prop_obj;            try {                prop_obj = JSON.parse(prop);            } catch (e) {                return Error(`Invalid property file: ${prop}`);            }            props.push(prop_obj);        }        return props;    } catch (e) {        console.error(e);        return [];    }}async function get_net_worth() {    let balance = await get_current_balance();    let properties = await get_owned_properties();    let loans = await get_loans();    let net_worth = balance.sanddollars;    for (let prop of properties){        net_worth += prop.sell_price;    }    for (let loan of loans){        net_worth -= loan.with_intrest;    }    return {        net_worth,        balance: balance.sanddollars,        properties,        loans    };}function Wallet(args) {    var _this = this;    _this = super_constructor(this, Wallet, args);    _this.balance = args[0];    _this.properties = args[1];    _this.loans = args[2];    _this.netWorth = args[3];    return _this;}Object.setPrototypeOf(Wallet.prototype, PythonObject.prototype);PICKLE_GLOBAL_SCOPE['__main__.Wallet'] = Wallet;function WalletRequest(args) {    var _this = this;    _this = super_constructor(this, WalletRequest, args);    return _this;}Object.setPrototypeOf(WalletRequest.prototype, Request.prototype);PICKLE_GLOBAL_SCOPE['__main__.WalletRequest'] = WalletRequest;WalletRequest.prototype.process = async function(ws) {    const info = await get_net_worth();    const res = WalletResponse([        info.balance,        info.properties.map((prop)=>PropertyToken([                prop.uuid,                prop.name,                prop.description,                prop.sell_price,                prop.image            ])),        info.loans,        info.net_worth    ]);    res.send(ws);};function WalletResponse(args) {    var _this = this;    _this = super_constructor(this, WalletResponse, args);    _this.wallet = Wallet(args);    return _this;}Object.setPrototypeOf(WalletResponse.prototype, Response.prototype);PICKLE_GLOBAL_SCOPE['__main__.WalletResponse'] = WalletResponse;function SellPropertyRequest(args) {    var _this = this;    _this = super_constructor(this, SellPropertyRequest, args);    _this.uuid = args[0];    return _this;}Object.setPrototypeOf(SellPropertyRequest.prototype, Request.prototype);PICKLE_GLOBAL_SCOPE['__main__.SellPropertyRequest'] = SellPropertyRequest;SellPropertyRequest.prototype.process = async function(ws) {    let properties = await get_owned_properties();    if (properties instanceof Error) {        SellPropertyResponse([            false,            `Failed to get properties: ${properties}`,            0        ]).send(ws);        return;    }    let uuid = this.uuid;    let target_prop = null;    let index = 0;    for (let prop of properties){        if (prop.uuid == uuid) {            target_prop = prop;            break;        }        index++;    }    if (!target_prop) {        SellPropertyResponse([            false,            "Property not found",            0        ]).send(ws);        return;    }    let range = random_int(0, Math.floor(target_prop.sell_price * .05));    range = range * (Math.random() > .33 ? 1 : -1);    let sale_price = target_prop.sell_price + Math.floor(range);    properties.splice(index, 1);    let file_path = `${ROOT}/wallet/properties/${target_prop.uuid}.token`;    try {        await Deno.remove(file_path);    } catch (e) {        console.error(e);        SellPropertyResponse([            false,            "Failed to remove property",            0        ]).send(ws);        return;    }    let balance = await get_current_balance();    balance.sanddollars += sale_price;    if (!await update_balance(balance)) {        SellPropertyResponse([            false,            "Failed to update balance",            0        ]).send(ws);        return;    }    SellPropertyResponse([        true,        `Property successfully sold for ${format_currency(sale_price)}`,        sale_price    ]).send(ws);};function SellPropertyResponse(args) {    var _this = this;    _this = super_constructor(this, SellPropertyResponse, args);    _this.success = args[0];    _this.message = args[1];    _this.sale_price = args[2];    return _this;}Object.setPrototypeOf(SellPropertyResponse.prototype, Response.prototype);PICKLE_GLOBAL_SCOPE['__main__.SellPropertyResponse'] = SellPropertyResponse;async function set_loans(loans) {    try {        loans = JSON.stringify(loans);        await Deno.writeTextFile(`${ROOT}/wallet/loans.json`, loans);        return true;    } catch (e) {        return false;    }}function NewLoanRequest(args) {    var _this = super_constructor(this, NewLoanRequest, args);    return _this;}NewLoanRequest.prototype = Object.create(Request.prototype);PICKLE_GLOBAL_SCOPE['__main__.NewLoanRequest'] = NewLoanRequest;NewLoanRequest.prototype.process = async function(ws) {    let loans = await get_loans();    let balance = await get_current_balance();    let val = random_int(1_000_000, 10_000_000);    val = Math.floor(val / 1000) * 1000;    let rate = 0.0005 - .000001 * random_int(0, 200);    let loan = {        amount: val,        rate: rate,        time: Math.floor(+Date.now())    };    loans.push(loan);    if (!await set_loans(loans)) {        NewLoanResponse([            false,            "Failed to create loan",            0        ]).send(ws);    }    balance.sanddollars += val;    if (!await update_balance(balance)) {        NewLoanResponse([            false,            "Failed to update balance",            0        ]).send(ws);    }    NewLoanResponse([        true,        `You received a loan of ${format_currency(loan.amount)}`,        loan.amount    ]).send(ws);};function NewLoanResponse(args) {    var _this = super_constructor(this, NewLoanResponse, args);    _this.success = args[0];    _this.message = args[1];    _this.value = args[2];    return _this;}NewLoanResponse.prototype = Object.create(Response.prototype);PICKLE_GLOBAL_SCOPE['__main__.NewLoanResponse'] = NewLoanResponse;function PayLoanRequest(args) {    var _this = super_constructor(this, PayLoanRequest, args);    _this.loan_index = args[0];    return _this;}PayLoanRequest.prototype = Object.create(Request.prototype);PICKLE_GLOBAL_SCOPE['__main__.PayLoanRequest'] = PayLoanRequest;PayLoanRequest.prototype.process = async function(ws) {    let loans = await get_loans();    let balance = await get_current_balance();    let indx = this.loan_index;    if (indx < 0 || indx >= loans.length) {        PayLoanResponse([            false,            "Invalid loan index"        ]).send(ws);        return;    }    let loan = loans[indx];    if (loan.with_intrest > balance.sanddollars) {        PayLoanResponse([            false,            "Insufficient funds"        ]).send(ws);        return;    }    balance.sanddollars -= loan.with_intrest;    if (!await update_balance(balance)) {        PayLoanResponse([            false,            "Failed to update balance"        ]).send(ws);        return;    }    loans.splice(indx, 1);    if (!await set_loans(loans)) {        PayLoanResponse([            false,            "Failed to update loans"        ]).send(ws);        return;    }    PayLoanResponse([        true,        "Loan paid"    ]).send(ws);};function PayLoanResponse(args) {    var _this = super_constructor(this, PayLoanResponse, args);    _this.success = args[0];    _this.message = args[1];    return _this;}PayLoanResponse.prototype = Object.create(Response.prototype);PICKLE_GLOBAL_SCOPE['__main__.PayLoanResponse'] = PayLoanResponse;auction_init();function ResetRequest(args) {    var _this = super_constructor(this, ResetRequest, args);    return _this;}ResetRequest.prototype = Object.create(Request.prototype);PICKLE_GLOBAL_SCOPE['__main__.ResetRequest'] = ResetRequest;ResetRequest.prototype.process = async function(ws) {    try {        await Deno.remove(`${ROOT}/wallet/loans.json`);    } catch (e) {}    try {        await Deno.remove(`${ROOT}/wallet/properties`, {            recursive: true        });    } catch (e) {}    try {        await Deno.remove(`${ROOT}/wallet/balance.json`);    } catch (e) {}    init();    ResetResponse([        true,        "Reset complete"    ]).send(ws);};function ResetResponse(args) {    var _this = super_constructor(this, ResetResponse, args);    _this.success = args[0];    _this.message = args[1];    return _this;}ResetResponse.prototype = Object.create(Response.prototype);PICKLE_GLOBAL_SCOPE['__main__.ResetResponse'] = ResetResponse;async function init() {    if (!await file_exists(`${ROOT}/wallet/balance.json`)) {        try {            await Deno.mkdir(`${ROOT}/wallet`);        } catch (e) {}        try {            await Deno.mkdir(`${ROOT}/wallet/properties`);        } catch (e) {}        await Deno.writeTextFile(`${ROOT}/wallet/loans.json`, '[]');        await Deno.writeTextFile(`${ROOT}/wallet/balance.json`, '{"sanddollars":3500000}');    }}await init();window.wss = new WebSocketServer(PORT);wss.on("connection", function(ws) {    const pws = new PickleWebsocket(ws);    window.current_client = pws;    ws.on("message", function(message) {        try {            pws.process(message);        } catch (e) {            console.error(e);            pws.send(Exception([                e.toString()            ]));        }    });});export { ResetRequest as ResetRequest };export { ResetResponse as ResetResponse };