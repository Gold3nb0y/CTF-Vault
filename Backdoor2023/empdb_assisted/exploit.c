#define _GNU_SOURCE
#include <bits/types/struct_itimerspec.h>
#include <bits/time.h>
#include <sys/timerfd.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <netinet/in.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <limits.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <linux/keyctl.h>
#include <sys/shm.h>
#include <ctype.h>

#define ALLOC 0x1337001
#define WRITE 0x1337001
#define READ  0x1337003
#define FREE  0x1337004

#define DATA_SIZE 0x300
#define HEXDUMP_COLS 0x10

char * filepath = "/dev/empdb\0";

typedef struct req_struct {
    ulong index;
    ulong loll;
    ulong size;
    char* data;
} req_t;

req_t* req;
char* data;
int dbfd;

void err_log(char * string){
    printf("[X] %s\n", string); 
    exit(1);
}

void info_log(char * message){
    printf("[*] %s\n", message);
    return;
}

void hexdump(void *mem, unsigned int len)
{
    unsigned int i, j;
    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)
    {
        if(i % HEXDUMP_COLS == 0)
        {
            printf("0x%06x: ", i);
        }
        if(i < len)
        {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        else /* end of block, just aligning for ASCII dump */
        {
            printf("   ");
        }
        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))
        {
            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++)
            {
                if(j >= len) /* end of block, not really printing */
                {
                    putchar(' ');
                }
                else if(isprint(((char*)mem)[j])) /* printable char */
                {
                    putchar(0xFF & ((char*)mem)[j]);        
                }
                else /* other char */
                {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
}

//wrap ioctl
void db_ioctl(ulong code){
    ioctl(dbfd, code, req);
    return;
}

//alloc to a specific cache of size size, then write the data pointed to by req to that place
void db_alloc(uint64_t idx, uint64_t head, uint64_t size){
    req->index = idx;
    req->loll = head;
    req->size = size;
    db_ioctl(ALLOC);
    return;
}

void db_write(uint64_t idx, uint64_t head, uint64_t size){
    req->index = idx;
    req->loll = head;
    req->size = size;
    db_ioctl(WRITE);
    return;
}

void db_read(uint64_t idx, uint64_t head, uint64_t size){
    req->index = idx;
    req->size = size;
    db_ioctl(WRITE);
    return;
}

void db_free(uint64_t idx, uint64_t head, uint64_t size){
    req->index = idx;
    db_ioctl(FREE);
    return;
}

int main(void){
    req = malloc(sizeof(req_t));
    data = malloc(DATA_SIZE);
    req->data = data;
    dbfd = open(filepath, O_RDWR);
    if(dbfd < 0) err_log("failed to open file");

    return 0;
}
