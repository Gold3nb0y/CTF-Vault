#define _GNU_SOURCE
#include <bits/types/struct_itimerspec.h>
#include <bits/time.h>
#include <sys/timerfd.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <netinet/in.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <limits.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <linux/keyctl.h>
#include <sys/shm.h>
#include <ctype.h>

#define MEMO_PCI_DEVICE_ID 0x1337

#define PORT_GET_RESULT  0
#define PORT_GET_INTFLAG 1

#define PORT_SET_COMMAND 0
#define PORT_DROP_IRQ    1

#define CMD_STORE_GETKEY 0x10
#define CMD_STORE_PAGE   0x11
#define CMD_STORE_FIN    0x12
#define CMD_LOAD_SETKEY  0x20
#define CMD_LOAD_PAGE    0x21
#define CMD_LOAD_FIN     0x22

#define RESULT_COMPLETE   0x00
#define RESULT_INPROGRESS 0x01
#define RESULT_FAILED     0xff

#define INT_CMD         (1<<0)
#define INT_READ_FILE   (1<<1)
#define INT_WRITE_FILE  (1<<2)
#define INT_SDMA        (1<<3)

#define EVENT_COMPLETE  (1<<0)
#define EVENT_FAILED    (1<<1)
#define EVENT_FILE_IO   (1<<2)
#define EVENT_SDMA_DONE (1<<3)
#define EVENT_CMD       (EVENT_COMPLETE|EVENT_FAILED)
#define EVENT_ANY		((1<<4)-1)

#define DATA_SIZE 0x400
#define NUMBER_FDS 0x10
#define MSG_SIZE 0x2e0
#define HEXDUMP_COLS 16

#define KEY_DESC_MAX_SIZE 512
#define PREFIX_BUF_LEN 16
#define RCU_HEAD_LEN 16
#define SPRAY_KEY_SIZE 10

char * filepath = "/dev/rose\0";
struct msg{
    long mtype;
    char mtext[MSG_SIZE];
};

struct keyring_payload {
    uint8_t prefix[PREFIX_BUF_LEN];
    uint8_t rcu_buf[RCU_HEAD_LEN];
    unsigned short len;
};

struct pipe_buffer {
    uint64_t page;
    uint32_t offset;
    uint32_t len;
    uint64_t ops;
    uint32_t flags;
    uint32_t pad;
    uint64_t private;
};

struct pipe_buf_operations {
  uint64_t confirm;
  uint64_t release;
  uint64_t steal;
  uint64_t get;
};

struct leak {
    long kaslr_base;
    long physmap_base;
};

typedef int32_t key_serial_t;

void err_log(char * string){
    printf("[X] %s\n", string); 
    exit(1);
}

void info_log(char * message){
    printf("[*] %s\n", message);
    return;
}

void hexdump(void *mem, unsigned int len)
{
    unsigned int i, j;
    for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)
    {
        if(i % HEXDUMP_COLS == 0)
        {
            printf("0x%06x: ", i);
        }
        if(i < len)
        {
            printf("%02x ", 0xFF & ((char*)mem)[i]);
        }
        else /* end of block, just aligning for ASCII dump */
        {
            printf("   ");
        }
        if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))
        {
            for(j = i - (HEXDUMP_COLS - 1); j <= i; j++)
            {
                if(j >= len) /* end of block, not really printing */
                {
                    putchar(' ');
                }
                else if(isprint(((char*)mem)[j])) /* printable char */
                {
                    putchar(0xFF & ((char*)mem)[j]);        
                }
                else /* other char */
                {
                    putchar('.');
                }
            }
            putchar('\n');
        }
    }
}

int open_device(){
    int fd;
    fd = open(filepath, O_RDWR);
    return fd;
}

int send_message(char msg_fill, uint64_t msg_type){
    struct msg to_send;
    int qid;
    to_send.mtype = msg_type;
    memset(to_send.mtext, msg_fill, MSG_SIZE);

    qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT);
    if(msgsnd(qid, &to_send, sizeof(to_send.mtext), 0) == -1) err_log("msgsnd");
    return qid; 
}

void fill_queue(int msg_queue, char *msg_text, uint32_t msg_len, uint64_t msg_type){
    struct msg to_send;
    to_send.mtype = msg_type + 2;
    memset(to_send.mtext, 0, MSG_SIZE);
    mempcpy(to_send.mtext, msg_text, msg_len);

    if(msgsnd(msg_queue, &to_send, sizeof(to_send.mtext), 0) == -1) err_log("msgsnd");
    return; 
}

void recv_mesgage(int qid, uint print_res){
    struct msg recieved_message;
    recieved_message.mtype = 1;
    memset(recieved_message.mtext, 0, MSG_SIZE);
    //printf("[*] qid %d\n", qid);
    if(msgrcv(qid, &recieved_message, MSG_SIZE, 0, IPC_NOWAIT | MSG_NOERROR) == -1) printf("[X] error msgrcv errno: 0x%x\n", errno);
    if(print_res) hexdump(recieved_message.mtext, MSG_SIZE); 
}

int main(void){
    puts("hello world");
    return 0;
}
